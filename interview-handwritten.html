<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>卡鲁秋 - 前端面试题汇总</title><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="4"/><meta charSet="utf-8"/><meta name="robots" content="follow, index"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><link rel="preload" href="/interview/_next/static/css/5518ada2dd4eaf66.css" as="style" crossorigin=""/><link rel="stylesheet" href="/interview/_next/static/css/5518ada2dd4eaf66.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/interview/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/interview/_next/static/chunks/webpack-b0a39061ef5434f8.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/framework-5429a50ba5373c56.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/main-846b70f57d3f15ee.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/pages/_app-9a697299b91baa3f.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/pages/%5Bslug%5D-e58918b5e268a43a.js" defer="" crossorigin=""></script><script src="/interview/_next/static/0BvK9mpzdk-hjo3dQXvDZ/_buildManifest.js" defer="" crossorigin=""></script><script src="/interview/_next/static/0BvK9mpzdk-hjo3dQXvDZ/_ssgManifest.js" defer="" crossorigin=""></script></head><body class="bg-white text-gray-700 antialiased"><div id="__next"><div class="flex h-full min-h-[100vh] w-full flex-col" style="flex-direction:column;min-height:100vh"><main class="flex flex-1 grow-[1] flex-col" style="flex:1"><div class="bg-white p-6"><div class="flex flex-col space-y-6"><article><header><h1 class="text-4xl font-bold"></h1></header><div></div></article></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"post":{"content":"## 笔试题\n### 怎么看待笔试题\n从我个人对面试的看法来说，我是很不喜欢面试的时候手写代码的，尤其是像Promise这样的代码。因为它并不能完全反应出应聘者的真实前端技术水平，并且这种记忆复杂代码的工作，在项目开发中也并不会发挥多大作用。\n\n所以如果是我招聘前端小伙伴的话，我多半是不会出笔试题的。\n\n当然我也能理解为什么很多公司的基础面试会考手写Promise，原因可能有以下几点：\n\n- 节省时间，手写代码能淘汰掉一大批没有基础的应聘者。\n- 虽然不能保证上限，但却可以确保下限。\n- 对于应届生来说，没有项目经验，只能出这类题了。\n- 智力筛选，能手写出Promise的同学，智力和记忆力应该不会太差。\n- 招认真准备的应聘者，能手写出Promise的一定是经过了一定时间的面试准备。\n\n### 笔试题该怎么准备\n- 使用ChatGPT：虽然ChatGPT取代程序员的工作短期来看可能性不大，但是用它来刷手写题真的很节省时间。\n- 持续更新各种面试手写题以及参考答案，隔一段时间来看看即可。\n- 尽量把每一个手写题在实际中的应用给讲一讲，比如像深拷贝、LRU、EventEmitter这些，当你知道它的应用之后，可能就更容易理解和记忆了。\n\n## 手写防抖函数\n``` javascript\nfunction debounce(func, delay) {\n  let timerId;\n  return function(...args) {\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n    timerId = setTimeout(() =\u003e {\n      func.apply(this, args);\n    }, delay);\n  }\n}\n```\n\n## 手写节流函数\n\n``` javascript\nfunction throttle(func, delay) {\n  let lastTime = 0;\n  return function(...args) {\n    const currentTime = Date.now();\n    if (currentTime - lastTime \u003e= delay) {\n      func.apply(this, args);\n      lastTime = currentTime;\n    }\n  }\n}\n```\n\n## EventEmitter发布订阅模式\nEventEmitter是一个常考题，用途很广泛，可以用于前端组件通信，用于Nodejs异步编程，另外它就是个发布订阅模式。\n\n``` javascript\nclass EventEmitter {\n  constructor() {\n    this.events = {}; // 用一个对象来保存事件和订阅者\n  }\n\n  // 添加事件\n  on(event, listener) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(listener);\n  }\n\n  // 触发事件\n  emit(event, ...args) {\n    const listeners = this.events[event] || [];\n    listeners.forEach((listener) =\u003e listener(...args));\n  }\n\n  // 移除事件\n  off(event, listener) {\n    const listeners = this.events[event] || [];\n    const index = listeners.indexOf(listener);\n    if (index \u003e= 0) {\n      listeners.splice(index, 1);\n    }\n  }\n}\n```\n\nEventEmitter包含三个核心方法：\n\n1. on(event, listener)：用于添加事件和订阅者。接收两个参数，event表示事件名称，listener表示订阅者的回调函数。\n\n2. emit(event, ...args)：用于触发事件。接收一个事件名称和任意数量的参数。当事件被触发时，所有订阅该事件的回调函数将被调用，并将参数传递给它们。\n\n3. off(event, listener)：用于移除事件和订阅者。接收两个参数，event表示事件名称，listener表示要移除的订阅者的回调函数。\n\n调用示例：\n\n``` javascript\nconst emitter = new EventEmitter();\n\n// 添加订阅者\nemitter.on('hello', (name) =\u003e {\n  console.log(`Hello, ${name}!`);\n});\n\n// 触发事件\nemitter.emit('hello', 'Tom'); // 输出：Hello, Tom!\n```\n\n## 手写Promise\n要实现一个符合 Promise/A+ 规范的 Promise，需要注意以下几个要点：\n\n1. 状态转移：Promise 可以处于三种状态之一，分别是“pending”（等待状态）、“fulfilled”（已完成状态）和“rejected”（已拒绝状态）。当 Promise 转移到已完成或已拒绝状态时，需要保证状态不可逆转。\n\n2. 异步处理：Promise 可以处理异步操作，例如使用定时器或者在事件回调中执行异步代码。需要确保在异步操作完成之后，Promise 状态可以正确地转移。\n\n3. 链式调用：Promise 支持链式调用，也就是说每次调用 then() 方法后，都会返回一个新的 Promise。在 Promise 链中，每个 Promise 的状态都会受到前一个 Promise 的影响，因此需要保证每个 Promise 都能正确处理自己的状态。\n\n4. 错误处理：当 Promise 被拒绝时，可以通过 catch() 方法或在 then() 方法中传入第二个参数来处理错误。需要保证错误能够正确地冒泡，并且能够捕获到所有可能出现的错误。\n\n5. 静态方法：Promise 还有一些静态方法，例如 Promise.all()、Promise.race()、Promise.resolve() 和 Promise.reject() 等。这些方法与实例方法有所不同，需要额外注意实现。\n\n6. 链式调用的值传递：在链式调用中，每个 then() 方法可以返回一个值或一个新的 Promise。如果返回一个值，后续的 then() 方法应该接收到这个值。如果返回一个新的 Promise，后续的 then() 方法应该等待这个 Promise 完成，并接收到它的结果。\n\n``` javascript\nclass MyPromise {\n  constructor(executor) {\n    this.state = 'pending';\n    this.value = null;\n    this.reason = null;\n    this.onResolvedCallbacks = [];\n    this.onRejectedCallbacks = [];\n\n    const resolve = (value) =\u003e {\n      if (this.state === 'pending') {\n        this.state = 'fulfilled';\n        this.value = value;\n        this.onResolvedCallbacks.forEach(callback =\u003e callback(value));\n      }\n    }\n\n    const reject = (reason) =\u003e {\n      if (this.state === 'pending') {\n        this.state = 'rejected';\n        this.reason = reason;\n        this.onRejectedCallbacks.forEach(callback =\u003e callback(reason));\n      }\n    }\n\n    try {\n      executor(resolve, reject);\n    } catch (error) {\n      reject(error);\n    }\n  }\n\n  then(onResolved, onRejected) {\n    onResolved = typeof onResolved === 'function' ? onResolved : value =\u003e value;\n    onRejected = typeof onRejected === 'function' ? onRejected : reason =\u003e { throw reason };\n\n    const promise = new MyPromise((resolve, reject) =\u003e {\n      const handle = (callback, state) =\u003e {\n        try {\n          const result = callback(this.value);\n          if (result instanceof MyPromise) {\n            result.then(resolve, reject);\n          } else {\n            state(result);\n          }\n        } catch (error) {\n          reject(error);\n        }\n      }\n\n      if (this.state === 'fulfilled') {\n        setTimeout(() =\u003e handle(onResolved, resolve), 0);\n      } else if (this.state === 'rejected') {\n        setTimeout(() =\u003e handle(onRejected, reject), 0);\n      } else {\n        this.onResolvedCallbacks.push(() =\u003e handle(onResolved, resolve));\n        this.onRejectedCallbacks.push(() =\u003e handle(onRejected, reject));\n      }\n    });\n\n    return promise;\n  }\n\n  catch(onRejected) {\n    return this.then(null, onRejected);\n  }\n\n  static resolve(value) {\n    return new MyPromise(resolve =\u003e resolve(value));\n  }\n\n  static reject(reason) {\n    return new MyPromise((_, reject) =\u003e reject(reason));\n  }\n\n  static all(promises) {\n    return new MyPromise((resolve, reject) =\u003e {\n      const results = [];\n      let count = 0;\n\n      const handleResult = (index, value) =\u003e {\n        results[index] = value;\n        count++;\n        if (count === promises.length) {\n          resolve(results);\n        }\n      }\n\n      for (let i = 0; i \u003c promises.length; i++) {\n        promises[i].then(value =\u003e handleResult(i, value), reject);\n      }\n    });\n  }\n\n  static race(promises) {\n    return new MyPromise((resolve, reject) =\u003e {\n      for (let i = 0; i \u003c promises.length; i++) {\n        promises[i].then(resolve, reject);\n      }\n    });\n  }\n}\n```\n\n## 手写LRU缓存算法\n\n``` javascript\nclass LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();\n  }\n\n  get(key) {\n    if (!this.cache.has(key)) {\n      return -1;\n    }\n    const value = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, value);\n    return value;\n  }\n\n  put(key, value) {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    } else if (this.cache.size \u003e= this.capacity) {\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n    this.cache.set(key, value);\n  }\n}\n```\n\n## 手写apply\n\n``` javascript\nFunction.prototype.myApply = function(context, argsArray) {\n  context = context || window;\n  context.fn = this;\n  let result;\n  if (argsArray) {\n    result = context.fn(...argsArray);\n  } else {\n    result = context.fn();\n  }\n  delete context.fn;\n  return result;\n}\n```\n\n## 手写bind\n``` javascript\nFunction.prototype.myBind = function (context, ...args) {\n  const fn = this;\n  return function (...args2) {\n    return fn.apply(context, [...args, ...args2]);\n  };\n};\n```\n\n## 手写call\n``` javascript\nFunction.prototype.myCall = function (context, ...args) {\n  const fn = Symbol(\"fn\");\n  context = context || window;\n  context[fn] = this;\n  const result = context[fn](...args);\n  delete context[fn];\n  return result;\n};\n```\n\n## 手写Object.create\n``` javascript\nfunction createObject(proto) {\n  function F() {}\n  F.prototype = proto;\n  return new F();\n}\n```\n\n创建一个空的函数F，然后将proto设置为F的原型，最后返回一个新的F实例。这个新实例的原型链就指向了proto。\n\n## 手写instanceof方法\n``` javascript\nfunction myInstanceOf(obj, constructor) {\n  // 首先判断参数是否合法\n  if (obj === null || typeof obj !== 'object') {\n    return false;\n  }\n\n  // 获取对象的原型\n  let proto = Object.getPrototypeOf(obj);\n\n  // 遍历原型链\n  while (proto !== null) {\n    if (proto === constructor.prototype) {\n      return true;\n    }\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return false;\n}\n```\n\n首先判断传入的 obj 是否是一个对象，如果不是则返回 false。接着获取对象的原型，然后遍历整个原型链。如果在原型链中找到了 `constructor.prototype`，则返回 true，否则返回 false。\n\n## 手写new操作符\n``` javascript\nfunction myNew(constructor, ...args) {\n  // 创建一个新对象，它的原型指向构造函数的原型对象\n  const obj = Object.create(constructor.prototype);\n\n  // 执行构造函数，并将 this 指向新对象\n  const result = constructor.apply(obj, args);\n\n  // 如果构造函数返回一个对象，则返回这个对象，否则返回新对象\n  return result instanceof Object ? result : obj;\n}\n```\n我们首先使用 `Object.create` 方法创建一个新对象，它的原型指向构造函数的原型对象。接着执行构造函数，并将 this 指向新对象。如果构造函数返回一个对象，则返回这个对象，否则返回新对象。\n\n## 函数柯里化\n``` javascript\nfunction curry(fn) {\n  return function curried(...args) {\n    if (args.length \u003e= fn.length) {\n      return fn.apply(this, args);\n    } else {\n      return function(...moreArgs) {\n        return curried.apply(this, args.concat(moreArgs));\n      };\n    }\n  };\n}\n```\n\n我们定义了一个 curry 函数，它接受一个函数 fn 作为参数，并返回一个新函数。这个新函数接受任意个数的参数，并通过递归的方式将这些参数拆分成一系列嵌套的函数，最终返回一个新函数，执行原函数 fn。\n\n## 手写Ajax\n``` javascript\nfunction ajax(method, url, data, successCallback, errorCallback) {\n  // 创建 XMLHttpRequest 对象\n  const xhr = new XMLHttpRequest();\n\n  // 监听 readyState 变化事件\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4) {\n      if (xhr.status === 200) {\n        // 请求成功，执行成功回调函数\n        successCallback(xhr.responseText);\n      } else {\n        // 请求失败，执行错误回调函数\n        errorCallback(xhr.status);\n      }\n    }\n  };\n\n  // 初始化请求\n  xhr.open(method, url, true);\n\n  // 设置请求头\n  xhr.setRequestHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\n\n  // 发送请求\n  xhr.send(data);\n}\n```\n\n1. 定义一个 ajax 函数，它接受五个参数：请求方法（method）、请求地址（url）、请求数据（data）、成功回调函数（successCallback）和错误回调函数（errorCallback）。\n\n2. 创建一个 XMLHttpRequest 对象，并设置它的 readyState 变化事件的回调函数。在回调函数中，判断 readyState 是否为 4，以及状态码是否为 200。如果是，则执行成功回调函数，并将响应文本作为参数传入；否则，执行错误回调函数，并将状态码作为参数传入。\n\n3. 接着，调用 open 方法初始化请求，并调用 setRequestHeader 方法设置请求头。最后，我们调用 send 方法发送请求，并将请求数据作为参数传入。\n\n## 数组去重\n\n1. 使用Set去重\n\n``` javascript\nfunction uniqueBySet(arr) {\n  return [...new Set(arr)];\n}\n```\n\n2. 使用Array.reduce()方法去重\n``` javascript\nfunction uniqueByReduce(arr) {\n  return arr.reduce((acc, cur) =\u003e {\n    if (!acc.includes(cur)) {\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n}\n```\n\n3. filter去重\n``` javascript\nfunction unique(arr) {\n  return arr.filter((item, index, array) =\u003e {\n    return array.indexOf(item) === index;\n  });\n}\n```\n\n## 数组扁平化\nJS 数组扁平化是将一个多维数组变成一维数组的操作，可以使用多种方法来实现，以下是其中一种手写实现：\n\n``` javascript\nfunction flatten(arr) {\n  return arr.reduce((prev, curr) =\u003e {\n    return prev.concat(Array.isArray(curr) ? flatten(curr) : curr);\n  }, []);\n}\n```\n\n使用数组的 reduce 方法来递归地将多维数组扁平化。对于每个元素，如果它是一个数组，则递归调用 flatten 函数将其扁平化；否则，将其直接加入结果数组中。最终，我们将所有结果数组拼接起来，得到一个一维数组。\n\n## 循环打印红黄绿\n``` javascript\nfunction printTrafficLight() {\n  const colors = ['红灯', '黄灯', '绿灯'];\n  let index = 0;\n  setInterval(() =\u003e {\n    console.log(colors[index]);\n    index = (index + 1) % colors.length;\n  }, 1000);\n}\n\nprintTrafficLight();\n```\n\n我们首先定义了一个包含三种颜色的数组 colors，以及一个变量 index，用于表示当前应该输出哪种颜色。然后，我们使用 setInterval 方法每隔 1 秒输出一种颜色，并将 index 增加 1，以便下次输出下一个颜色。由于我们需要循环输出颜色，当 index 增加到 3 时，我们使用模运算将其重置为 0，从而重新开始循环输出。\n\n## 手写继承\n一般只需要实现组合寄生继承的形式就可以了,它通过借用构造函数来继承父类的属性，通过原型链来继承父类的方法，并使用寄生方式来修复原型链：\n\n``` javascript\nfunction inheritPrototype(subType, superType) {\n  const prototype = Object.create(superType.prototype);\n  prototype.constructor = subType;\n  subType.prototype = prototype;\n}\n\nfunction Animal(name) {\n  this.name = name;\n  this.colors = ['white', 'black'];\n}\n\nAnimal.prototype.eat = function() {\n  console.log(this.name + ' is eating.');\n};\n\nfunction Dog(name) {\n  Animal.call(this, name);\n  this.type = 'dog';\n}\n\ninheritPrototype(Dog, Animal);\n\nDog.prototype.bark = function() {\n  console.log(this.name + ' is barking.');\n};\n\nconst dog = new Dog('Snoopy');\ndog.eat(); // 输出 \"Snoopy is eating.\"\ndog.bark(); // 输出 \"Snoopy is barking.\"\n```","slug":"interview-handwritten","html":"\u003ch2\u003e笔试题\u003c/h2\u003e\n\u003ch3\u003e怎么看待笔试题\u003c/h3\u003e\n\u003cp\u003e从我个人对面试的看法来说，我是很不喜欢面试的时候手写代码的，尤其是像Promise这样的代码。因为它并不能完全反应出应聘者的真实前端技术水平，并且这种记忆复杂代码的工作，在项目开发中也并不会发挥多大作用。\u003c/p\u003e\n\u003cp\u003e所以如果是我招聘前端小伙伴的话，我多半是不会出笔试题的。\u003c/p\u003e\n\u003cp\u003e当然我也能理解为什么很多公司的基础面试会考手写Promise，原因可能有以下几点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e节省时间，手写代码能淘汰掉一大批没有基础的应聘者。\u003c/li\u003e\n\u003cli\u003e虽然不能保证上限，但却可以确保下限。\u003c/li\u003e\n\u003cli\u003e对于应届生来说，没有项目经验，只能出这类题了。\u003c/li\u003e\n\u003cli\u003e智力筛选，能手写出Promise的同学，智力和记忆力应该不会太差。\u003c/li\u003e\n\u003cli\u003e招认真准备的应聘者，能手写出Promise的一定是经过了一定时间的面试准备。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e笔试题该怎么准备\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e使用ChatGPT：虽然ChatGPT取代程序员的工作短期来看可能性不大，但是用它来刷手写题真的很节省时间。\u003c/li\u003e\n\u003cli\u003e持续更新各种面试手写题以及参考答案，隔一段时间来看看即可。\u003c/li\u003e\n\u003cli\u003e尽量把每一个手写题在实际中的应用给讲一讲，比如像深拷贝、LRU、EventEmitter这些，当你知道它的应用之后，可能就更容易理解和记忆了。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e手写防抖函数\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction debounce(func, delay) {\n  let timerId;\n  return function(...args) {\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n    timerId = setTimeout(() =\u003e {\n      func.apply(this, args);\n    }, delay);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e手写节流函数\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction throttle(func, delay) {\n  let lastTime = 0;\n  return function(...args) {\n    const currentTime = Date.now();\n    if (currentTime - lastTime \u003e= delay) {\n      func.apply(this, args);\n      lastTime = currentTime;\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eEventEmitter发布订阅模式\u003c/h2\u003e\n\u003cp\u003eEventEmitter是一个常考题，用途很广泛，可以用于前端组件通信，用于Nodejs异步编程，另外它就是个发布订阅模式。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eclass EventEmitter {\n  constructor() {\n    this.events = {}; // 用一个对象来保存事件和订阅者\n  }\n\n  // 添加事件\n  on(event, listener) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(listener);\n  }\n\n  // 触发事件\n  emit(event, ...args) {\n    const listeners = this.events[event] || [];\n    listeners.forEach((listener) =\u003e listener(...args));\n  }\n\n  // 移除事件\n  off(event, listener) {\n    const listeners = this.events[event] || [];\n    const index = listeners.indexOf(listener);\n    if (index \u003e= 0) {\n      listeners.splice(index, 1);\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEventEmitter包含三个核心方法：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eon(event, listener)：用于添加事件和订阅者。接收两个参数，event表示事件名称，listener表示订阅者的回调函数。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eemit(event, ...args)：用于触发事件。接收一个事件名称和任意数量的参数。当事件被触发时，所有订阅该事件的回调函数将被调用，并将参数传递给它们。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eoff(event, listener)：用于移除事件和订阅者。接收两个参数，event表示事件名称，listener表示要移除的订阅者的回调函数。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e调用示例：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst emitter = new EventEmitter();\n\n// 添加订阅者\nemitter.on('hello', (name) =\u003e {\n  console.log(`Hello, ${name}!`);\n});\n\n// 触发事件\nemitter.emit('hello', 'Tom'); // 输出：Hello, Tom!\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e手写Promise\u003c/h2\u003e\n\u003cp\u003e要实现一个符合 Promise/A+ 规范的 Promise，需要注意以下几个要点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e状态转移：Promise 可以处于三种状态之一，分别是“pending”（等待状态）、“fulfilled”（已完成状态）和“rejected”（已拒绝状态）。当 Promise 转移到已完成或已拒绝状态时，需要保证状态不可逆转。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e异步处理：Promise 可以处理异步操作，例如使用定时器或者在事件回调中执行异步代码。需要确保在异步操作完成之后，Promise 状态可以正确地转移。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e链式调用：Promise 支持链式调用，也就是说每次调用 then() 方法后，都会返回一个新的 Promise。在 Promise 链中，每个 Promise 的状态都会受到前一个 Promise 的影响，因此需要保证每个 Promise 都能正确处理自己的状态。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e错误处理：当 Promise 被拒绝时，可以通过 catch() 方法或在 then() 方法中传入第二个参数来处理错误。需要保证错误能够正确地冒泡，并且能够捕获到所有可能出现的错误。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e静态方法：Promise 还有一些静态方法，例如 Promise.all()、Promise.race()、Promise.resolve() 和 Promise.reject() 等。这些方法与实例方法有所不同，需要额外注意实现。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e链式调用的值传递：在链式调用中，每个 then() 方法可以返回一个值或一个新的 Promise。如果返回一个值，后续的 then() 方法应该接收到这个值。如果返回一个新的 Promise，后续的 then() 方法应该等待这个 Promise 完成，并接收到它的结果。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eclass MyPromise {\n  constructor(executor) {\n    this.state = 'pending';\n    this.value = null;\n    this.reason = null;\n    this.onResolvedCallbacks = [];\n    this.onRejectedCallbacks = [];\n\n    const resolve = (value) =\u003e {\n      if (this.state === 'pending') {\n        this.state = 'fulfilled';\n        this.value = value;\n        this.onResolvedCallbacks.forEach(callback =\u003e callback(value));\n      }\n    }\n\n    const reject = (reason) =\u003e {\n      if (this.state === 'pending') {\n        this.state = 'rejected';\n        this.reason = reason;\n        this.onRejectedCallbacks.forEach(callback =\u003e callback(reason));\n      }\n    }\n\n    try {\n      executor(resolve, reject);\n    } catch (error) {\n      reject(error);\n    }\n  }\n\n  then(onResolved, onRejected) {\n    onResolved = typeof onResolved === 'function' ? onResolved : value =\u003e value;\n    onRejected = typeof onRejected === 'function' ? onRejected : reason =\u003e { throw reason };\n\n    const promise = new MyPromise((resolve, reject) =\u003e {\n      const handle = (callback, state) =\u003e {\n        try {\n          const result = callback(this.value);\n          if (result instanceof MyPromise) {\n            result.then(resolve, reject);\n          } else {\n            state(result);\n          }\n        } catch (error) {\n          reject(error);\n        }\n      }\n\n      if (this.state === 'fulfilled') {\n        setTimeout(() =\u003e handle(onResolved, resolve), 0);\n      } else if (this.state === 'rejected') {\n        setTimeout(() =\u003e handle(onRejected, reject), 0);\n      } else {\n        this.onResolvedCallbacks.push(() =\u003e handle(onResolved, resolve));\n        this.onRejectedCallbacks.push(() =\u003e handle(onRejected, reject));\n      }\n    });\n\n    return promise;\n  }\n\n  catch(onRejected) {\n    return this.then(null, onRejected);\n  }\n\n  static resolve(value) {\n    return new MyPromise(resolve =\u003e resolve(value));\n  }\n\n  static reject(reason) {\n    return new MyPromise((_, reject) =\u003e reject(reason));\n  }\n\n  static all(promises) {\n    return new MyPromise((resolve, reject) =\u003e {\n      const results = [];\n      let count = 0;\n\n      const handleResult = (index, value) =\u003e {\n        results[index] = value;\n        count++;\n        if (count === promises.length) {\n          resolve(results);\n        }\n      }\n\n      for (let i = 0; i \u0026#x3C; promises.length; i++) {\n        promises[i].then(value =\u003e handleResult(i, value), reject);\n      }\n    });\n  }\n\n  static race(promises) {\n    return new MyPromise((resolve, reject) =\u003e {\n      for (let i = 0; i \u0026#x3C; promises.length; i++) {\n        promises[i].then(resolve, reject);\n      }\n    });\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e手写LRU缓存算法\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eclass LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();\n  }\n\n  get(key) {\n    if (!this.cache.has(key)) {\n      return -1;\n    }\n    const value = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, value);\n    return value;\n  }\n\n  put(key, value) {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    } else if (this.cache.size \u003e= this.capacity) {\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n    this.cache.set(key, value);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e手写apply\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eFunction.prototype.myApply = function(context, argsArray) {\n  context = context || window;\n  context.fn = this;\n  let result;\n  if (argsArray) {\n    result = context.fn(...argsArray);\n  } else {\n    result = context.fn();\n  }\n  delete context.fn;\n  return result;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e手写bind\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eFunction.prototype.myBind = function (context, ...args) {\n  const fn = this;\n  return function (...args2) {\n    return fn.apply(context, [...args, ...args2]);\n  };\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e手写call\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eFunction.prototype.myCall = function (context, ...args) {\n  const fn = Symbol(\"fn\");\n  context = context || window;\n  context[fn] = this;\n  const result = context[fn](...args);\n  delete context[fn];\n  return result;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e手写Object.create\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction createObject(proto) {\n  function F() {}\n  F.prototype = proto;\n  return new F();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e创建一个空的函数F，然后将proto设置为F的原型，最后返回一个新的F实例。这个新实例的原型链就指向了proto。\u003c/p\u003e\n\u003ch2\u003e手写instanceof方法\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction myInstanceOf(obj, constructor) {\n  // 首先判断参数是否合法\n  if (obj === null || typeof obj !== 'object') {\n    return false;\n  }\n\n  // 获取对象的原型\n  let proto = Object.getPrototypeOf(obj);\n\n  // 遍历原型链\n  while (proto !== null) {\n    if (proto === constructor.prototype) {\n      return true;\n    }\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return false;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e首先判断传入的 obj 是否是一个对象，如果不是则返回 false。接着获取对象的原型，然后遍历整个原型链。如果在原型链中找到了 \u003ccode\u003econstructor.prototype\u003c/code\u003e，则返回 true，否则返回 false。\u003c/p\u003e\n\u003ch2\u003e手写new操作符\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction myNew(constructor, ...args) {\n  // 创建一个新对象，它的原型指向构造函数的原型对象\n  const obj = Object.create(constructor.prototype);\n\n  // 执行构造函数，并将 this 指向新对象\n  const result = constructor.apply(obj, args);\n\n  // 如果构造函数返回一个对象，则返回这个对象，否则返回新对象\n  return result instanceof Object ? result : obj;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e我们首先使用 \u003ccode\u003eObject.create\u003c/code\u003e 方法创建一个新对象，它的原型指向构造函数的原型对象。接着执行构造函数，并将 this 指向新对象。如果构造函数返回一个对象，则返回这个对象，否则返回新对象。\u003c/p\u003e\n\u003ch2\u003e函数柯里化\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction curry(fn) {\n  return function curried(...args) {\n    if (args.length \u003e= fn.length) {\n      return fn.apply(this, args);\n    } else {\n      return function(...moreArgs) {\n        return curried.apply(this, args.concat(moreArgs));\n      };\n    }\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e我们定义了一个 curry 函数，它接受一个函数 fn 作为参数，并返回一个新函数。这个新函数接受任意个数的参数，并通过递归的方式将这些参数拆分成一系列嵌套的函数，最终返回一个新函数，执行原函数 fn。\u003c/p\u003e\n\u003ch2\u003e手写Ajax\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction ajax(method, url, data, successCallback, errorCallback) {\n  // 创建 XMLHttpRequest 对象\n  const xhr = new XMLHttpRequest();\n\n  // 监听 readyState 变化事件\n  xhr.onreadystatechange = function() {\n    if (xhr.readyState === 4) {\n      if (xhr.status === 200) {\n        // 请求成功，执行成功回调函数\n        successCallback(xhr.responseText);\n      } else {\n        // 请求失败，执行错误回调函数\n        errorCallback(xhr.status);\n      }\n    }\n  };\n\n  // 初始化请求\n  xhr.open(method, url, true);\n\n  // 设置请求头\n  xhr.setRequestHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\n\n  // 发送请求\n  xhr.send(data);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e定义一个 ajax 函数，它接受五个参数：请求方法（method）、请求地址（url）、请求数据（data）、成功回调函数（successCallback）和错误回调函数（errorCallback）。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e创建一个 XMLHttpRequest 对象，并设置它的 readyState 变化事件的回调函数。在回调函数中，判断 readyState 是否为 4，以及状态码是否为 200。如果是，则执行成功回调函数，并将响应文本作为参数传入；否则，执行错误回调函数，并将状态码作为参数传入。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e接着，调用 open 方法初始化请求，并调用 setRequestHeader 方法设置请求头。最后，我们调用 send 方法发送请求，并将请求数据作为参数传入。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e数组去重\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e使用Set去重\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction uniqueBySet(arr) {\n  return [...new Set(arr)];\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e使用Array.reduce()方法去重\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction uniqueByReduce(arr) {\n  return arr.reduce((acc, cur) =\u003e {\n    if (!acc.includes(cur)) {\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003efilter去重\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction unique(arr) {\n  return arr.filter((item, index, array) =\u003e {\n    return array.indexOf(item) === index;\n  });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e数组扁平化\u003c/h2\u003e\n\u003cp\u003eJS 数组扁平化是将一个多维数组变成一维数组的操作，可以使用多种方法来实现，以下是其中一种手写实现：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction flatten(arr) {\n  return arr.reduce((prev, curr) =\u003e {\n    return prev.concat(Array.isArray(curr) ? flatten(curr) : curr);\n  }, []);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e使用数组的 reduce 方法来递归地将多维数组扁平化。对于每个元素，如果它是一个数组，则递归调用 flatten 函数将其扁平化；否则，将其直接加入结果数组中。最终，我们将所有结果数组拼接起来，得到一个一维数组。\u003c/p\u003e\n\u003ch2\u003e循环打印红黄绿\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction printTrafficLight() {\n  const colors = ['红灯', '黄灯', '绿灯'];\n  let index = 0;\n  setInterval(() =\u003e {\n    console.log(colors[index]);\n    index = (index + 1) % colors.length;\n  }, 1000);\n}\n\nprintTrafficLight();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e我们首先定义了一个包含三种颜色的数组 colors，以及一个变量 index，用于表示当前应该输出哪种颜色。然后，我们使用 setInterval 方法每隔 1 秒输出一种颜色，并将 index 增加 1，以便下次输出下一个颜色。由于我们需要循环输出颜色，当 index 增加到 3 时，我们使用模运算将其重置为 0，从而重新开始循环输出。\u003c/p\u003e\n\u003ch2\u003e手写继承\u003c/h2\u003e\n\u003cp\u003e一般只需要实现组合寄生继承的形式就可以了,它通过借用构造函数来继承父类的属性，通过原型链来继承父类的方法，并使用寄生方式来修复原型链：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction inheritPrototype(subType, superType) {\n  const prototype = Object.create(superType.prototype);\n  prototype.constructor = subType;\n  subType.prototype = prototype;\n}\n\nfunction Animal(name) {\n  this.name = name;\n  this.colors = ['white', 'black'];\n}\n\nAnimal.prototype.eat = function() {\n  console.log(this.name + ' is eating.');\n};\n\nfunction Dog(name) {\n  Animal.call(this, name);\n  this.type = 'dog';\n}\n\ninheritPrototype(Dog, Animal);\n\nDog.prototype.bark = function() {\n  console.log(this.name + ' is barking.');\n};\n\nconst dog = new Dog('Snoopy');\ndog.eat(); // 输出 \"Snoopy is eating.\"\ndog.bark(); // 输出 \"Snoopy is barking.\"\n\u003c/code\u003e\u003c/pre\u003e\n"}},"__N_SSG":true},"page":"/[slug]","query":{"slug":"interview-handwritten"},"buildId":"0BvK9mpzdk-hjo3dQXvDZ","assetPrefix":"/interview","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>