<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>卡鲁秋 - 前端面试题汇总</title><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="4"/><meta charSet="utf-8"/><meta name="robots" content="follow, index"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><link rel="preload" href="/interview/_next/static/css/5518ada2dd4eaf66.css" as="style" crossorigin=""/><link rel="stylesheet" href="/interview/_next/static/css/5518ada2dd4eaf66.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/interview/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/interview/_next/static/chunks/webpack-b0a39061ef5434f8.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/framework-5429a50ba5373c56.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/main-846b70f57d3f15ee.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/pages/_app-9a697299b91baa3f.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/pages/%5Bslug%5D-e58918b5e268a43a.js" defer="" crossorigin=""></script><script src="/interview/_next/static/rgorwgb_bGkfLTb_t-crr/_buildManifest.js" defer="" crossorigin=""></script><script src="/interview/_next/static/rgorwgb_bGkfLTb_t-crr/_ssgManifest.js" defer="" crossorigin=""></script></head><body class="bg-white text-gray-700 antialiased"><div id="__next"><div class="flex h-full min-h-[100vh] w-full flex-col" style="flex-direction:column;min-height:100vh"><main class="flex flex-1 grow-[1] flex-col" style="flex:1"><div class="bg-white p-6"><div class="flex flex-col space-y-6"><article><header><h1 class="text-4xl font-bold"></h1></header><div></div></article></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"post":{"content":"## setState是同步还是异步\n\n### v18之前\n\n- React是希望setState表现为异步的，因为批量更新可以优化性能。因此在React能够管控到的地方，比如生命周期钩子和合成事件回调函数内，表现为异步。\n- 在定时器和原生事件里，因为React管控不到，所以表现为同步。\n- 在某些情况下，我们需要立即获取更新后的状态，这时可以使用第二个可选参数callback，在状态更新后立即执行回调函数来获取更新后的状态。例如：\n\n``` javascript\nthis.setState({ counter: this.state.counter + 1 }, () =\u003e {\n  console.log(this.state.counter); // 输出更新后的值\n});\n```\n\n### v18之后\n\n- React18之后，默认所有的操作都放到批处理中，因此setState不管在那儿调用都是异步的了。\n- 如果希望同步更新，可以使用flushSync这个API。\n\n## React组件通信方式有哪些\n\n老生常谈的题了，背答案不是目的，好的回答是对于每种场景能举出自己在实际项目中的应用。\n\n- Props: 父组件可以通过 props 将数据传递给子组件。子组件可以通过 this.props 访问这些数据。\n- Callback: 父组件可以通过回调函数将函数传递给子组件。子组件可以在适当的时候调用这些回调函数，以便与父组件通信。\n- Context: 上下文是一种在组件树中共享数据的方法。通过 context，可以在组件树中传递数据，而不需要在每个级别显式地将 props 传递给所有组件。\n- Redux: 复杂应用全局状态管理可以使用Redux、Mobx等状态管理库，项目里一般使用React Redux或者RTK工具包。\n- Pub/Sub: 发布/订阅模式是一种通过事件来进行任意组件间通信的方法，和Vue里的事件总线原理一样。\n- Hooks里也可以通过useReducer和useContext来实现全局组件通信。\n\n## 在项目中怎么使用Redux\n\nRedux是一个通用的JS库，一般在React项目里不会直接使用Redux，在项目中使用的一般是react-redux。\n\n现在React官方推荐的是RTK工具包，使用起来更简洁，不用写很多样板代码，代码可读性更好。\n\n当然也可以根据公司的需求，自研状态管理方案。\n\n## Redux中间件是什么？实现原理\n\n中间件的本质就是个函数，在Redux每次写数据的时候执行，用来实现一些通用的功能。\n\n常见的中间件功能包括异步中间件、持久化中间件、log中间件。\n\nRedux中间件的实现原理和Koa中间件、Axios拦截器类似，数组里面存函数，然后compose调用中间件函数，并传递参数给中间件。\n\n## 函数式组件和类组件有什么区别\n\n可以从写法，逻辑复用等角度来谈一谈区别。\n\n- 类组件：有props、state和生命周期，可以实现复杂UI和交互。\n- 函数式组件：在Hooks之前，函数式组件就是纯渲染组件，接收props返回React元素。Hooks之后，函数式组件有了能表达交互的能力。\n- 逻辑复用：类组件可以通过HOC和Mixin实现逻辑复用，函数式组件可以通过Hooks实现逻辑复用。\n\n## React逻辑复用方式有哪些\n组件封装和逻辑复用，是前端进阶必备的，小伙伴们可以多花点时间深入研究，这里只是简要总结。\n\n- Mixin：有很多缺点，已被弃用，可以不考虑。\n- HOC(高阶组件)：高阶组件是一个函数，它接收一个组件作为参数并返回一个新的组件。高阶组件可以将一些通用的逻辑（如：数据获取、权限验证、错误处理等）封装到一个函数中，并将其作为高阶组件的参数传递给其他组件使用，HOC一般以withXxx命名，并可以结合装饰器优雅地使用。\n- Render Props：通过在组件中传递一个函数作为prop，该函数将用于渲染组件的内容。这个函数可以接收组件需要的数据和方法，并返回React元素。\n- Hooks：自定义Hooks，将通用逻辑封装到useXxx函数中，可以在多个组件内使用，常见的像数据请求、表单、防抖节流、拖拽等。\n\n## 使用Hooks有踩过哪些坑\n\n- useEffect中没有正确设置依赖数组导致死循环。\n- useEffect中没有清除副作用导致内存泄漏。\n- 在条件语句和循环中使用Hooks导致报错。\n- 闭包陷阱。\n\n## useRef有什么作用\n\n- 获取DOM。\n- 存储上一次渲染的值，可以用useRef创建一个对象来存储setState前的旧值。\n\n## useMemo和useCallback有什么作用\n\n1. useMemo类似于Vue的计算属性。\n\n``` javascript\nimport React, { useMemo } from 'react';\n\nfunction ExpensiveComponent({ data }) {\n  const expensiveResult = useMemo(() =\u003e {\n    // 计算昂贵的结果\n    return data.filter(item =\u003e item \u003e 10);\n  }, [data]);\n\n  return \u003cdiv\u003e{expensiveResult}\u003c/div\u003e;\n}\n```\n\n2. useCallback：大多数人认为useCallback的作用是缓存函数的生成，但在实际应用中这种优化是微不足道的，useCallback真正的作用是在函数需要作为prop传递给子组件时，使用useCallback包裹可以避免子组件无谓的更新。\n\n## React代码层面有哪些性能优化的方式\n\n- React.memo()：可以缓存组件的渲染结果，避免不必要的重渲染。它接受一个函数组件，并返回一个新的组件，新组件将只在props发生变化时才重新渲染。\n- useMemo和useCallback。\n- shouldComponentUpdate：在类组件中，可以通过实现shouldComponentUpdate()方法来判断组件是否需要重新渲染。SCU接收两个参数：nextProps和nextState，我们可以在这个方法中比较当前props和state与下一个props和state的变化来决定是否需要重新渲染组件。\n- 使用React.lazy()和Suspense进行组件懒加载。\n- 对于大型应用，可以使用不可变数据的三方库比如Immer.js结合shouldComponentUpdate来做性能优化。\n\n## 什么是受控组件和非受控组件\n受控组件和非受控组件是针对表单的。\n\n### 受控组件：(类似于Vue的双向绑定)\n\nReact默认不是双向绑定的，也就是说当我们在输入框输入的时候，输入框绑定的值并不会自动变化。\n\n通过给input绑定onChange事件，让React实现类似于Vue的双向绑定，这就叫受控组件。\n\n### 非受控组件\n\n非受控组件是让用户手动操作Dom来控制表单值。\n\n非受控组件的好处是更自由，可以更方便地自行选择三方库来处理表单。\n\n## 什么是eject？\n\nnpm run eject命令可以将 create-react-app 创建的 React 项目里的配置文件暴露出来，以便我们自定义配置。\n\n比如以下场景：\n\n- 配置Less等预编译器语法。\n- 使用PostCSS工具来做移动端自动适配。\n- 搭建Typescript开发环境。\n- Webpack优化。\n\n## Hooks实现原理\n篇幅有限，这里只做简要总结，实现细节后续会出文讲解。\n\n1. **memorizedState**：Fiber节点上有个属性叫memorizedState，所有的Hooks都是围绕这个memorizedState来实现的，把要存的状态和函数队列存到这个属性上，然后按需求做增删改查就行了。\n\n2. **链表存储状态**：为了保证Hooks状态的序列，React采用链表来保存函数式组件的state，使用next属性来连接前后两个状态序列。\n\n## JSX和模板引擎有什么区别\nJSX：更加灵活，既可以写标签，也可以使用JS语法和表达式，在做复杂渲染时更得心应手。\n\n模板引擎：更简单易上手，开发效率高，结合指令的可读性也比较好。\n\nJSX太灵活就导致没法给编译器提供太多的优化线索，不好做静态优化，模板引擎可以在编译时做静态标记，性能更好。\n\nJSX只是个编译工具，Vue经过一定的配置也可以使用。\n\n## 怎么理解Fiber和并发模式\n\n### 为什么要设计并发模式？\n\n在React的旧版本中，当组件状态发生变化时，React会将整个组件树进行递归遍历，生成新的虚拟DOM树，并与旧的虚拟DOM树进行比较，找出需要更新的部分，然后将这些部分更新到DOM中。这种遍历方式虽然简单，但是在组件树变得非常大、复杂的情况下，会导致渲染和更新性能下降，造成页面卡顿甚至无法响应用户操作的情况。为了解决这个问题，React引入了并发模式。\n\n### Fiber是什么？\n\n- Fiber是一种数据结构，由VDOM转化生成。\n- Fiber的思想是将组件树的遍历过程拆分成多个小的、可中断的任务，以实现更细粒度的控制和优化。\n- 具体来说，Fiber将每个组件看作是一个执行单元，并将组件树转换成一棵Fiber树。每个Fiber节点都包含了组件的状态和一些额外的信息，例如优先级、副作用等。\n- 在更新过程中，React会根据Fiber节点的优先级，将Fiber树转换成一个任务队列，然后按照优先级进行调度和执行。React还会利用浏览器提供的requestIdleCallback API来分配空闲时间，以避免阻塞渲染线程。\n- 由于Fiber将组件树的遍历过程拆分成了多个小的、可中断的任务，因此React可以在需要更新的部分进行优化，从而提高渲染和更新的性能。例如，在执行更新任务时，React可以根据优先级调整任务的执行顺序，避免低优先级任务阻塞高优先级任务的执行，提高了应用程序的响应速度和性能。\n\n## Vue和React有哪些区别，你更喜欢哪个\n这是个开放题，不建议背答案，可以从**生态、语法、性能、原理、开发体验**等方面去试着比较一下。\n\n网上关于这两个框架谁更好争吵的也很凶，实际上无论是Vue和React，都可以开发出优秀的应用，关键在于如何正确使用。与其争论哪个更好，不如两个都学好，拿着高薪看别人对线它不香嘛。\n\n## 有了解过哪些类React框架，谈谈你对它们的看法\n- Preact：可以理解为简易版React，但是和React有一样的API，性能比React还好，甚至也实现了并发模式，对于想要阅读React源码又觉得难的同学，可以看一看Preact的源码。\n\n- Svelte：无虚拟Dom，依靠编译器和纯响应式的轻量级框架，然而性能却非常好。\n\n- SolidJS：和Svelte类似，但是SolidJS的语法更接近于React，Svelte的语法接近Vue。\n\n总结一下：\n\n- 这些类React或者类Vue框架，可能在某一方面或者某些方面表现很出色。\n- 在开发成熟项目时，还是尽量选择Vue和React，因为毕竟生态和解决方案更多。\n- 时间允许的话推荐阅读这些框架的源码，它们的代码量相对少，容易阅读，能让你有一个更广的视野来看待前端框架的原理和设计思路。","slug":"interview-react","html":"\u003ch2\u003esetState是同步还是异步\u003c/h2\u003e\n\u003ch3\u003ev18之前\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eReact是希望setState表现为异步的，因为批量更新可以优化性能。因此在React能够管控到的地方，比如生命周期钩子和合成事件回调函数内，表现为异步。\u003c/li\u003e\n\u003cli\u003e在定时器和原生事件里，因为React管控不到，所以表现为同步。\u003c/li\u003e\n\u003cli\u003e在某些情况下，我们需要立即获取更新后的状态，这时可以使用第二个可选参数callback，在状态更新后立即执行回调函数来获取更新后的状态。例如：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003ethis.setState({ counter: this.state.counter + 1 }, () =\u003e {\n  console.log(this.state.counter); // 输出更新后的值\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003ev18之后\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eReact18之后，默认所有的操作都放到批处理中，因此setState不管在那儿调用都是异步的了。\u003c/li\u003e\n\u003cli\u003e如果希望同步更新，可以使用flushSync这个API。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eReact组件通信方式有哪些\u003c/h2\u003e\n\u003cp\u003e老生常谈的题了，背答案不是目的，好的回答是对于每种场景能举出自己在实际项目中的应用。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eProps: 父组件可以通过 props 将数据传递给子组件。子组件可以通过 this.props 访问这些数据。\u003c/li\u003e\n\u003cli\u003eCallback: 父组件可以通过回调函数将函数传递给子组件。子组件可以在适当的时候调用这些回调函数，以便与父组件通信。\u003c/li\u003e\n\u003cli\u003eContext: 上下文是一种在组件树中共享数据的方法。通过 context，可以在组件树中传递数据，而不需要在每个级别显式地将 props 传递给所有组件。\u003c/li\u003e\n\u003cli\u003eRedux: 复杂应用全局状态管理可以使用Redux、Mobx等状态管理库，项目里一般使用React Redux或者RTK工具包。\u003c/li\u003e\n\u003cli\u003ePub/Sub: 发布/订阅模式是一种通过事件来进行任意组件间通信的方法，和Vue里的事件总线原理一样。\u003c/li\u003e\n\u003cli\u003eHooks里也可以通过useReducer和useContext来实现全局组件通信。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e在项目中怎么使用Redux\u003c/h2\u003e\n\u003cp\u003eRedux是一个通用的JS库，一般在React项目里不会直接使用Redux，在项目中使用的一般是react-redux。\u003c/p\u003e\n\u003cp\u003e现在React官方推荐的是RTK工具包，使用起来更简洁，不用写很多样板代码，代码可读性更好。\u003c/p\u003e\n\u003cp\u003e当然也可以根据公司的需求，自研状态管理方案。\u003c/p\u003e\n\u003ch2\u003eRedux中间件是什么？实现原理\u003c/h2\u003e\n\u003cp\u003e中间件的本质就是个函数，在Redux每次写数据的时候执行，用来实现一些通用的功能。\u003c/p\u003e\n\u003cp\u003e常见的中间件功能包括异步中间件、持久化中间件、log中间件。\u003c/p\u003e\n\u003cp\u003eRedux中间件的实现原理和Koa中间件、Axios拦截器类似，数组里面存函数，然后compose调用中间件函数，并传递参数给中间件。\u003c/p\u003e\n\u003ch2\u003e函数式组件和类组件有什么区别\u003c/h2\u003e\n\u003cp\u003e可以从写法，逻辑复用等角度来谈一谈区别。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e类组件：有props、state和生命周期，可以实现复杂UI和交互。\u003c/li\u003e\n\u003cli\u003e函数式组件：在Hooks之前，函数式组件就是纯渲染组件，接收props返回React元素。Hooks之后，函数式组件有了能表达交互的能力。\u003c/li\u003e\n\u003cli\u003e逻辑复用：类组件可以通过HOC和Mixin实现逻辑复用，函数式组件可以通过Hooks实现逻辑复用。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eReact逻辑复用方式有哪些\u003c/h2\u003e\n\u003cp\u003e组件封装和逻辑复用，是前端进阶必备的，小伙伴们可以多花点时间深入研究，这里只是简要总结。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMixin：有很多缺点，已被弃用，可以不考虑。\u003c/li\u003e\n\u003cli\u003eHOC(高阶组件)：高阶组件是一个函数，它接收一个组件作为参数并返回一个新的组件。高阶组件可以将一些通用的逻辑（如：数据获取、权限验证、错误处理等）封装到一个函数中，并将其作为高阶组件的参数传递给其他组件使用，HOC一般以withXxx命名，并可以结合装饰器优雅地使用。\u003c/li\u003e\n\u003cli\u003eRender Props：通过在组件中传递一个函数作为prop，该函数将用于渲染组件的内容。这个函数可以接收组件需要的数据和方法，并返回React元素。\u003c/li\u003e\n\u003cli\u003eHooks：自定义Hooks，将通用逻辑封装到useXxx函数中，可以在多个组件内使用，常见的像数据请求、表单、防抖节流、拖拽等。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e使用Hooks有踩过哪些坑\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003euseEffect中没有正确设置依赖数组导致死循环。\u003c/li\u003e\n\u003cli\u003euseEffect中没有清除副作用导致内存泄漏。\u003c/li\u003e\n\u003cli\u003e在条件语句和循环中使用Hooks导致报错。\u003c/li\u003e\n\u003cli\u003e闭包陷阱。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003euseRef有什么作用\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e获取DOM。\u003c/li\u003e\n\u003cli\u003e存储上一次渲染的值，可以用useRef创建一个对象来存储setState前的旧值。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003euseMemo和useCallback有什么作用\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003euseMemo类似于Vue的计算属性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eimport React, { useMemo } from 'react';\n\nfunction ExpensiveComponent({ data }) {\n  const expensiveResult = useMemo(() =\u003e {\n    // 计算昂贵的结果\n    return data.filter(item =\u003e item \u003e 10);\n  }, [data]);\n\n  return \u0026#x3C;div\u003e{expensiveResult}\u0026#x3C;/div\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003euseCallback：大多数人认为useCallback的作用是缓存函数的生成，但在实际应用中这种优化是微不足道的，useCallback真正的作用是在函数需要作为prop传递给子组件时，使用useCallback包裹可以避免子组件无谓的更新。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eReact代码层面有哪些性能优化的方式\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eReact.memo()：可以缓存组件的渲染结果，避免不必要的重渲染。它接受一个函数组件，并返回一个新的组件，新组件将只在props发生变化时才重新渲染。\u003c/li\u003e\n\u003cli\u003euseMemo和useCallback。\u003c/li\u003e\n\u003cli\u003eshouldComponentUpdate：在类组件中，可以通过实现shouldComponentUpdate()方法来判断组件是否需要重新渲染。SCU接收两个参数：nextProps和nextState，我们可以在这个方法中比较当前props和state与下一个props和state的变化来决定是否需要重新渲染组件。\u003c/li\u003e\n\u003cli\u003e使用React.lazy()和Suspense进行组件懒加载。\u003c/li\u003e\n\u003cli\u003e对于大型应用，可以使用不可变数据的三方库比如Immer.js结合shouldComponentUpdate来做性能优化。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e什么是受控组件和非受控组件\u003c/h2\u003e\n\u003cp\u003e受控组件和非受控组件是针对表单的。\u003c/p\u003e\n\u003ch3\u003e受控组件：(类似于Vue的双向绑定)\u003c/h3\u003e\n\u003cp\u003eReact默认不是双向绑定的，也就是说当我们在输入框输入的时候，输入框绑定的值并不会自动变化。\u003c/p\u003e\n\u003cp\u003e通过给input绑定onChange事件，让React实现类似于Vue的双向绑定，这就叫受控组件。\u003c/p\u003e\n\u003ch3\u003e非受控组件\u003c/h3\u003e\n\u003cp\u003e非受控组件是让用户手动操作Dom来控制表单值。\u003c/p\u003e\n\u003cp\u003e非受控组件的好处是更自由，可以更方便地自行选择三方库来处理表单。\u003c/p\u003e\n\u003ch2\u003e什么是eject？\u003c/h2\u003e\n\u003cp\u003enpm run eject命令可以将 create-react-app 创建的 React 项目里的配置文件暴露出来，以便我们自定义配置。\u003c/p\u003e\n\u003cp\u003e比如以下场景：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e配置Less等预编译器语法。\u003c/li\u003e\n\u003cli\u003e使用PostCSS工具来做移动端自动适配。\u003c/li\u003e\n\u003cli\u003e搭建Typescript开发环境。\u003c/li\u003e\n\u003cli\u003eWebpack优化。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eHooks实现原理\u003c/h2\u003e\n\u003cp\u003e篇幅有限，这里只做简要总结，实现细节后续会出文讲解。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003ememorizedState\u003c/strong\u003e：Fiber节点上有个属性叫memorizedState，所有的Hooks都是围绕这个memorizedState来实现的，把要存的状态和函数队列存到这个属性上，然后按需求做增删改查就行了。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e链表存储状态\u003c/strong\u003e：为了保证Hooks状态的序列，React采用链表来保存函数式组件的state，使用next属性来连接前后两个状态序列。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eJSX和模板引擎有什么区别\u003c/h2\u003e\n\u003cp\u003eJSX：更加灵活，既可以写标签，也可以使用JS语法和表达式，在做复杂渲染时更得心应手。\u003c/p\u003e\n\u003cp\u003e模板引擎：更简单易上手，开发效率高，结合指令的可读性也比较好。\u003c/p\u003e\n\u003cp\u003eJSX太灵活就导致没法给编译器提供太多的优化线索，不好做静态优化，模板引擎可以在编译时做静态标记，性能更好。\u003c/p\u003e\n\u003cp\u003eJSX只是个编译工具，Vue经过一定的配置也可以使用。\u003c/p\u003e\n\u003ch2\u003e怎么理解Fiber和并发模式\u003c/h2\u003e\n\u003ch3\u003e为什么要设计并发模式？\u003c/h3\u003e\n\u003cp\u003e在React的旧版本中，当组件状态发生变化时，React会将整个组件树进行递归遍历，生成新的虚拟DOM树，并与旧的虚拟DOM树进行比较，找出需要更新的部分，然后将这些部分更新到DOM中。这种遍历方式虽然简单，但是在组件树变得非常大、复杂的情况下，会导致渲染和更新性能下降，造成页面卡顿甚至无法响应用户操作的情况。为了解决这个问题，React引入了并发模式。\u003c/p\u003e\n\u003ch3\u003eFiber是什么？\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eFiber是一种数据结构，由VDOM转化生成。\u003c/li\u003e\n\u003cli\u003eFiber的思想是将组件树的遍历过程拆分成多个小的、可中断的任务，以实现更细粒度的控制和优化。\u003c/li\u003e\n\u003cli\u003e具体来说，Fiber将每个组件看作是一个执行单元，并将组件树转换成一棵Fiber树。每个Fiber节点都包含了组件的状态和一些额外的信息，例如优先级、副作用等。\u003c/li\u003e\n\u003cli\u003e在更新过程中，React会根据Fiber节点的优先级，将Fiber树转换成一个任务队列，然后按照优先级进行调度和执行。React还会利用浏览器提供的requestIdleCallback API来分配空闲时间，以避免阻塞渲染线程。\u003c/li\u003e\n\u003cli\u003e由于Fiber将组件树的遍历过程拆分成了多个小的、可中断的任务，因此React可以在需要更新的部分进行优化，从而提高渲染和更新的性能。例如，在执行更新任务时，React可以根据优先级调整任务的执行顺序，避免低优先级任务阻塞高优先级任务的执行，提高了应用程序的响应速度和性能。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eVue和React有哪些区别，你更喜欢哪个\u003c/h2\u003e\n\u003cp\u003e这是个开放题，不建议背答案，可以从\u003cstrong\u003e生态、语法、性能、原理、开发体验\u003c/strong\u003e等方面去试着比较一下。\u003c/p\u003e\n\u003cp\u003e网上关于这两个框架谁更好争吵的也很凶，实际上无论是Vue和React，都可以开发出优秀的应用，关键在于如何正确使用。与其争论哪个更好，不如两个都学好，拿着高薪看别人对线它不香嘛。\u003c/p\u003e\n\u003ch2\u003e有了解过哪些类React框架，谈谈你对它们的看法\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003ePreact：可以理解为简易版React，但是和React有一样的API，性能比React还好，甚至也实现了并发模式，对于想要阅读React源码又觉得难的同学，可以看一看Preact的源码。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eSvelte：无虚拟Dom，依靠编译器和纯响应式的轻量级框架，然而性能却非常好。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eSolidJS：和Svelte类似，但是SolidJS的语法更接近于React，Svelte的语法接近Vue。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e总结一下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e这些类React或者类Vue框架，可能在某一方面或者某些方面表现很出色。\u003c/li\u003e\n\u003cli\u003e在开发成熟项目时，还是尽量选择Vue和React，因为毕竟生态和解决方案更多。\u003c/li\u003e\n\u003cli\u003e时间允许的话推荐阅读这些框架的源码，它们的代码量相对少，容易阅读，能让你有一个更广的视野来看待前端框架的原理和设计思路。\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/[slug]","query":{"slug":"interview-react"},"buildId":"rgorwgb_bGkfLTb_t-crr","assetPrefix":"/interview","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>