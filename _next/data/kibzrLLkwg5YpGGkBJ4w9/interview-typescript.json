{"pageProps":{"post":{"content":"## TS有什么优缺点？为什么要用TS？\n\n### TS 的优点：\n\n- 可以减少低级的语法错误。\n- 规范团队代码，对大型项目来说规范很重要。\n- 智能提示，定义类型能让编辑器更好的自动提示，提升编码效率。\n\n### TS 的缺点：\n\n- 学习成本高。\n- 开发成本高，又要做业务又要编写类型文件，有时候还得解决奇奇怪怪的报错。\n\n### 适用场景：\n\n- 大型项目和团队开发。\n- 库和框架开发。\n- 对于一些重要的逻辑或者代码，可以使用TS来增强其可靠性。\n\n## 什么是泛型,有什么作用？\n\nTS泛型简单来说就是类型参数，在定义某些函数、接口和类时，不写死类型，而是改用类型参数的形式，让类型更加灵活。\n\n举个简单的例子，我们定义一个数据响应体的接口：\n\n``` typescript\ninterface IResponseData<T>{\n    code: number;\n    message?: string;\n    data: T;\n}\n```\n\n其中data的类型并没有写死，而是可以在我们使用的时候传入：\n\n``` typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// 使用时传入User类型\nconst response: IResponseData<User> = {\n  code: 200,\n  message: \"Success\",\n  data: {\n    id: 1,\n    name: \"xiaoming\",\n    email: \"xxx@qq.com\"\n  }\n};\n```\n\n## 类型别名type和接口interface有什么区别？\n\n1. 类型别名不能被继承或者实现，接口可以被继承或者实现。\n2. 类型别名可以定义任何类型，包括联合类型、交叉类型、字面量类型、原始类型等。接口只能定义对象类型，包括属性、方法、索引等。\n3. 类型别名通常用于为复杂类型创建别名，以方便在代码中使用。接口通常用于定义某个实体的结构，以及实现该结构的对象或类。\n\n总结一下，如果你需要定义一个对象类型，或者需要使用继承和实现的特性，那么应该使用接口；如果你需要定义任意类型的别名，或者需要定义联合类型和交叉类型等复杂类型，那么应该使用类型别名。\n\n## 什么是装饰器？\n\n装饰器的作用，简单来说就是代码复用，和Java里的注解以及Rust里的属性宏类似。\n\n把通用的代码封装成装饰器，然后在使用的时候就可以将`@xxx`添加在方法或者类上，方法和类就得到了加强，特别简洁优雅。\n\n例如mobx里的`@observable`以及NestJS里的`@Controller`。\n\n举个简单的自定义装饰器例子，我们来实现一个自动打印函数参数以及返回值的装饰器。\n\n首先来定义装饰器：\n\n``` Typescript\n// target表示装饰的目标对象\n// propertyKey表示装饰的属性或方法名\n// descriptor表示属性或方法的描述符\nfunction log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const originalMethod = descriptor.value;\n\n  descriptor.value = function (...args: any[]) {\n    console.log(`调用 ${propertyKey}，参数为: ${JSON.stringify(args)}`);\n    const result = originalMethod.apply(this, args);\n    console.log(`方法 ${propertyKey} 返回值为: ${JSON.stringify(result)}`);\n    return result;\n  };\n\n  return descriptor;\n}\n```\n\n然后使用一下这个装饰器：\n\n``` typescript\nclass Test {\n  @log\n  add(a: number, b: number) {\n    return a + b;\n  }\n}\n\nconst test = new Test();\nconsole.log(test.add(2, 3)); // 会打印出参数2,3和返回值5\n```\n\n## 什么是类型体操，有哪些应用？\n\nTS类型体操指的是用各种技巧和骚操作来创建复杂类型。\n\n类型体操一般在业务项目里出现的少，在三方库里出现的多，比如Vue3源码里面就有很多复杂的类型体操运算。\n\n关于类型体操，褒贬不一，有人认为是秀操作，实际作用不大，也有人认为很高级。\n\n我个人是不太倾向在前端项目里执着于玩类型体操的，但是一些常见的TS技巧是需要学习的，比如类型别名、交叉类型和联合类型、条件类型、工具类型、泛型，在处理复杂类型运算的时候，就很有用。\n\n## any用的多吗，有什么弊端？\n\n使用any类型的主要目的是在不清楚变量类型的情况下避免编译错误，但是，频繁地使用any类型那就等于白白浪费了TS的类型检查能力。\n\n正确的做法是尽可能避免使用any类型，尽可能地使用明确的类型，这样可以提高代码的可读性和可维护性，并且可以减少潜在的运行时错误。\n\n但是有时候时间紧任务重又不得不用，所以一句话总结就是，尽量不用，不到万不得已不轻易用any。\n\n## 你知道哪些工具类型，怎么用？\n\n工具类型主要用于处理和转换已有类型，它们不是实际的类型，而是用来处理类型的工具。简单来说，工具类型可以认为是TS类型的工具函数，把原有类型当参数来处理。\n\n举一个简单的Partial工具类型应用的例子：\n\n``` typescript\n// 已有类型User\ninterface User {\n  name: string;\n  age: number;\n}\n\n// 新类型PartialUser，使用Partial将属性都变成可选\ntype PartialUser = Partial<User>; // { name?: string; age?: number; }\n```\n\n常用工具类型有：\n\n- **Partial<T>**：将类型 T 的所有属性变为可选属性。\n- **Required<T>**：将类型 T 的所有属性变为必选属性。\n- **Readonly<T>**：将类型 T 的所有属性变为只读属性。\n- **Record<K, T>**：创建一个类型，其中属性名为类型 K 中的值，属性值为类型 T 中的值。\n- **Pick<T, K>**：从类型 T 中选择属性名为类型 K 中的属性，创建一个新类型。\n- **Omit<T, K>**：从类型 T 中排除属性名为类型 K 中的属性，创建一个新类型。\n- **Exclude<T, U>**：从类型 T 中排除类型 U 中的所有属性。\n- **Extract<T, U>**：从类型 T 中提取类型 U 中存在的所有属性。\n- **NonNullable<T>**：从类型 T 中移除 null 和 undefined。\n- **ReturnType<T>**：获取函数类型 T 的返回值类型。\n\n## TS里怎么处理第三方库类型，怎么给第三方库编写类型文件？\n\nTS社区维护了一个名为DefinitelyTyped的项目，提供了大量的第三方库的类型定义文件，大多数三方库类型文件都可以直接在这里面下载。\n\n但是如果第三方库没有提供类型定义文件时，我们可以通过手动编写类型文件的方式，为第三方库添加类型支持。\n\n给三方库编写类型的文件步骤如下：\n\n1. 创建d.ts文件：在项目中创建一个新的d.ts文件，文件名可以与库名相同，例如`lodash.d.ts`。\n\n2. 定义模块：使用`declare module`语句定义模块名，模块名应与库的导出模块名一致。例如，对于lodash库，可以这样定义模块：\n\n``` Typescript\ndeclare module 'lodash' {\n  // 在此处添加类型定义\n}\n```\n\n3. 添加类型定义：在模块内部添加对应的类型定义，例如函数、变量、类等。根据需要，可以使用 interface、type、class 等关键字定义不同类型的接口。\n\n4. 导出类型：使用 export 关键字导出需要公开的类型。例如，对于以下的 utils 函数，可以这样定义：\n\n``` typescript\ndeclare module 'lodash' {\n  function utils(...args: any[]): any;\n  export { utils };\n}\n```\n\n5. 使用类型文件：在需要使用第三方库的地方，通过import语句引入类型定义即可：\n\n``` typescript\nimport { utils } from 'lodash';\n```\n\n## React项目怎么使用TS？Vue项目怎么使用TS？\n\n### React：\nReact脚手架自带TS模板，新建项目的时候，带上参数即可。\n\nReact项目里需要考虑类型的地方主要有：\n\n- 定义props和state的类型。\n- 事件处理函数中事件对象的类型，尽量不要用any。\n- 对三方库的封装要考虑类型。\n- 对于Hooks的参数和返回值的约束类型。\n- 数据接口需要定义类型。\n\n### Vue：\n\n- Vue2项目可以通过添加 class-component 和 vue-property-decorator 库来使用TS。\n\n- Vue3对TS支持更好，可以通过vue-cli或者vite来直接启动TS模板的脚手架。","slug":"interview-typescript","html":"<h2>TS有什么优缺点？为什么要用TS？</h2>\n<h3>TS 的优点：</h3>\n<ul>\n<li>可以减少低级的语法错误。</li>\n<li>规范团队代码，对大型项目来说规范很重要。</li>\n<li>智能提示，定义类型能让编辑器更好的自动提示，提升编码效率。</li>\n</ul>\n<h3>TS 的缺点：</h3>\n<ul>\n<li>学习成本高。</li>\n<li>开发成本高，又要做业务又要编写类型文件，有时候还得解决奇奇怪怪的报错。</li>\n</ul>\n<h3>适用场景：</h3>\n<ul>\n<li>大型项目和团队开发。</li>\n<li>库和框架开发。</li>\n<li>对于一些重要的逻辑或者代码，可以使用TS来增强其可靠性。</li>\n</ul>\n<h2>什么是泛型,有什么作用？</h2>\n<p>TS泛型简单来说就是类型参数，在定义某些函数、接口和类时，不写死类型，而是改用类型参数的形式，让类型更加灵活。</p>\n<p>举个简单的例子，我们定义一个数据响应体的接口：</p>\n<pre><code class=\"language-typescript\">interface IResponseData&#x3C;T>{\n    code: number;\n    message?: string;\n    data: T;\n}\n</code></pre>\n<p>其中data的类型并没有写死，而是可以在我们使用的时候传入：</p>\n<pre><code class=\"language-typescript\">interface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// 使用时传入User类型\nconst response: IResponseData&#x3C;User> = {\n  code: 200,\n  message: \"Success\",\n  data: {\n    id: 1,\n    name: \"xiaoming\",\n    email: \"xxx@qq.com\"\n  }\n};\n</code></pre>\n<h2>类型别名type和接口interface有什么区别？</h2>\n<ol>\n<li>类型别名不能被继承或者实现，接口可以被继承或者实现。</li>\n<li>类型别名可以定义任何类型，包括联合类型、交叉类型、字面量类型、原始类型等。接口只能定义对象类型，包括属性、方法、索引等。</li>\n<li>类型别名通常用于为复杂类型创建别名，以方便在代码中使用。接口通常用于定义某个实体的结构，以及实现该结构的对象或类。</li>\n</ol>\n<p>总结一下，如果你需要定义一个对象类型，或者需要使用继承和实现的特性，那么应该使用接口；如果你需要定义任意类型的别名，或者需要定义联合类型和交叉类型等复杂类型，那么应该使用类型别名。</p>\n<h2>什么是装饰器？</h2>\n<p>装饰器的作用，简单来说就是代码复用，和Java里的注解以及Rust里的属性宏类似。</p>\n<p>把通用的代码封装成装饰器，然后在使用的时候就可以将<code>@xxx</code>添加在方法或者类上，方法和类就得到了加强，特别简洁优雅。</p>\n<p>例如mobx里的<code>@observable</code>以及NestJS里的<code>@Controller</code>。</p>\n<p>举个简单的自定义装饰器例子，我们来实现一个自动打印函数参数以及返回值的装饰器。</p>\n<p>首先来定义装饰器：</p>\n<pre><code class=\"language-Typescript\">// target表示装饰的目标对象\n// propertyKey表示装饰的属性或方法名\n// descriptor表示属性或方法的描述符\nfunction log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const originalMethod = descriptor.value;\n\n  descriptor.value = function (...args: any[]) {\n    console.log(`调用 ${propertyKey}，参数为: ${JSON.stringify(args)}`);\n    const result = originalMethod.apply(this, args);\n    console.log(`方法 ${propertyKey} 返回值为: ${JSON.stringify(result)}`);\n    return result;\n  };\n\n  return descriptor;\n}\n</code></pre>\n<p>然后使用一下这个装饰器：</p>\n<pre><code class=\"language-typescript\">class Test {\n  @log\n  add(a: number, b: number) {\n    return a + b;\n  }\n}\n\nconst test = new Test();\nconsole.log(test.add(2, 3)); // 会打印出参数2,3和返回值5\n</code></pre>\n<h2>什么是类型体操，有哪些应用？</h2>\n<p>TS类型体操指的是用各种技巧和骚操作来创建复杂类型。</p>\n<p>类型体操一般在业务项目里出现的少，在三方库里出现的多，比如Vue3源码里面就有很多复杂的类型体操运算。</p>\n<p>关于类型体操，褒贬不一，有人认为是秀操作，实际作用不大，也有人认为很高级。</p>\n<p>我个人是不太倾向在前端项目里执着于玩类型体操的，但是一些常见的TS技巧是需要学习的，比如类型别名、交叉类型和联合类型、条件类型、工具类型、泛型，在处理复杂类型运算的时候，就很有用。</p>\n<h2>any用的多吗，有什么弊端？</h2>\n<p>使用any类型的主要目的是在不清楚变量类型的情况下避免编译错误，但是，频繁地使用any类型那就等于白白浪费了TS的类型检查能力。</p>\n<p>正确的做法是尽可能避免使用any类型，尽可能地使用明确的类型，这样可以提高代码的可读性和可维护性，并且可以减少潜在的运行时错误。</p>\n<p>但是有时候时间紧任务重又不得不用，所以一句话总结就是，尽量不用，不到万不得已不轻易用any。</p>\n<h2>你知道哪些工具类型，怎么用？</h2>\n<p>工具类型主要用于处理和转换已有类型，它们不是实际的类型，而是用来处理类型的工具。简单来说，工具类型可以认为是TS类型的工具函数，把原有类型当参数来处理。</p>\n<p>举一个简单的Partial工具类型应用的例子：</p>\n<pre><code class=\"language-typescript\">// 已有类型User\ninterface User {\n  name: string;\n  age: number;\n}\n\n// 新类型PartialUser，使用Partial将属性都变成可选\ntype PartialUser = Partial&#x3C;User>; // { name?: string; age?: number; }\n</code></pre>\n<p>常用工具类型有：</p>\n<ul>\n<li><strong>Partial</strong>：将类型 T 的所有属性变为可选属性。</li>\n<li><strong>Required</strong>：将类型 T 的所有属性变为必选属性。</li>\n<li><strong>Readonly</strong>：将类型 T 的所有属性变为只读属性。</li>\n<li><strong>Record&#x3C;K, T></strong>：创建一个类型，其中属性名为类型 K 中的值，属性值为类型 T 中的值。</li>\n<li><strong>Pick&#x3C;T, K></strong>：从类型 T 中选择属性名为类型 K 中的属性，创建一个新类型。</li>\n<li><strong>Omit&#x3C;T, K></strong>：从类型 T 中排除属性名为类型 K 中的属性，创建一个新类型。</li>\n<li><strong>Exclude&#x3C;T, U></strong>：从类型 T 中排除类型 U 中的所有属性。</li>\n<li><strong>Extract&#x3C;T, U></strong>：从类型 T 中提取类型 U 中存在的所有属性。</li>\n<li><strong>NonNullable</strong>：从类型 T 中移除 null 和 undefined。</li>\n<li><strong>ReturnType</strong>：获取函数类型 T 的返回值类型。</li>\n</ul>\n<h2>TS里怎么处理第三方库类型，怎么给第三方库编写类型文件？</h2>\n<p>TS社区维护了一个名为DefinitelyTyped的项目，提供了大量的第三方库的类型定义文件，大多数三方库类型文件都可以直接在这里面下载。</p>\n<p>但是如果第三方库没有提供类型定义文件时，我们可以通过手动编写类型文件的方式，为第三方库添加类型支持。</p>\n<p>给三方库编写类型的文件步骤如下：</p>\n<ol>\n<li>\n<p>创建d.ts文件：在项目中创建一个新的d.ts文件，文件名可以与库名相同，例如<code>lodash.d.ts</code>。</p>\n</li>\n<li>\n<p>定义模块：使用<code>declare module</code>语句定义模块名，模块名应与库的导出模块名一致。例如，对于lodash库，可以这样定义模块：</p>\n</li>\n</ol>\n<pre><code class=\"language-Typescript\">declare module 'lodash' {\n  // 在此处添加类型定义\n}\n</code></pre>\n<ol start=\"3\">\n<li>\n<p>添加类型定义：在模块内部添加对应的类型定义，例如函数、变量、类等。根据需要，可以使用 interface、type、class 等关键字定义不同类型的接口。</p>\n</li>\n<li>\n<p>导出类型：使用 export 关键字导出需要公开的类型。例如，对于以下的 utils 函数，可以这样定义：</p>\n</li>\n</ol>\n<pre><code class=\"language-typescript\">declare module 'lodash' {\n  function utils(...args: any[]): any;\n  export { utils };\n}\n</code></pre>\n<ol start=\"5\">\n<li>使用类型文件：在需要使用第三方库的地方，通过import语句引入类型定义即可：</li>\n</ol>\n<pre><code class=\"language-typescript\">import { utils } from 'lodash';\n</code></pre>\n<h2>React项目怎么使用TS？Vue项目怎么使用TS？</h2>\n<h3>React：</h3>\n<p>React脚手架自带TS模板，新建项目的时候，带上参数即可。</p>\n<p>React项目里需要考虑类型的地方主要有：</p>\n<ul>\n<li>定义props和state的类型。</li>\n<li>事件处理函数中事件对象的类型，尽量不要用any。</li>\n<li>对三方库的封装要考虑类型。</li>\n<li>对于Hooks的参数和返回值的约束类型。</li>\n<li>数据接口需要定义类型。</li>\n</ul>\n<h3>Vue：</h3>\n<ul>\n<li>\n<p>Vue2项目可以通过添加 class-component 和 vue-property-decorator 库来使用TS。</p>\n</li>\n<li>\n<p>Vue3对TS支持更好，可以通过vue-cli或者vite来直接启动TS模板的脚手架。</p>\n</li>\n</ul>\n"}},"__N_SSG":true}