{"pageProps":{"post":{"content":"## 算法面试心得\n\n关于算法面试，实在是没什么太好的捷径，如果想面试外企或者对算法要求比较高的企业，老老实实刷Leetcode就得了。\n\n对于怎么刷Leetcode，在这里给一些建议：\n\n- 分类刷题，比如动态规划、双指针、二叉树这些。刷多了你就会发现，同一个类型的题，解题套路和编码步骤都是类似的。\n- 尽量少刷难度为Hard的题，对于前端来说，面试中碰到Hard的算法题概率还是很低的，刷难度高的题一是收益不大，二是可能会打击你的信心。\n- 对于非计算机专业或者算法基础薄弱的同学，有空闲时间最好找一些课程系统地学习数据结构和算法，不然直接刷题会面临很多挑战。\n- 保持耐心别着急，贵在坚持，一周哪怕就刷两道题，只要消化了就好。\n- 实际上绝大多数企业包括大厂，其实对前端的算法能力要求并不会太高，一本《剑指Offer》足矣。\n\n## 快排\n最常见的基础算法，很多面试一上来就让写个快排，所以必须掌握。\n\n思路：把一个数组分成两个子数组来递归地解决问题，选择一个基准值，然后将小于等于基准值的元素移到数组左侧，将大于基准值的元素移到数组右侧，再对左右两个子数组递归进行排序，最终得到一个有序的数组。\n\n``` javascript\nfunction quickSort(arr) {\n  if (arr.length <= 1) {  // 如果数组长度小于等于1，直接返回\n    return arr;\n  }\n  const pivotIndex = Math.floor(arr.length / 2);  // 选择基准值\n  const pivot = arr.splice(pivotIndex, 1)[0];  // 将基准值从数组中删除，并保存基准值\n  const left = [], right = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < pivot) {  // 将小于基准值的元素放入左子数组\n      left.push(arr[i]);\n    } else {  // 将大于等于基准值的元素放入右子数组\n      right.push(arr[i]);\n    }\n  }\n  return quickSort(left).concat([pivot], quickSort(right));  // 对左右子数组递归进行排序，最终合并为一个有序数组\n}\n\n// 示例\nconst arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];\nconsole.log(quickSort(arr));  // [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]\n```\n\n## 二分搜索\n利用数组有序这一特点，将查找区间不断缩小一半，从而快速地定位目标元素。\n\n``` javascript\nfunction binarySearch(arr, target) {\n  let left = 0, right = arr.length - 1;\n  while (left <= right) {  // 当查找区间非空时\n    const mid = Math.floor((left + right) / 2);  // 计算中间位置\n    if (arr[mid] === target) {  // 如果中间位置的元素就是目标元素，直接返回\n      return mid;\n    } else if (arr[mid] < target) {  // 如果中间位置的元素小于目标元素，将查找区间缩小为右半部分\n      left = mid + 1;\n    } else {  // 如果中间位置的元素大于目标元素，将查找区间缩小为左半部分\n      right = mid - 1;\n    }\n  }\n  return -1;  // 如果没有找到目标元素，返回-1\n}\n\n// 示例\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nconsole.log(binarySearch(arr, 5));  // 4\nconsole.log(binarySearch(arr, 10));  // -1\n```\n\n## LRU缓存算法\n\n有缓存的地方就有LRU，比如说Vue的keep-alive就是用的LRU缓存算法实现的。\n\n``` javascript\nclass LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;  // 缓存容量\n    this.map = new Map();  // 使用Map来存储缓存数据，实现O(1)的查找和删除\n  }\n\n  get(key) {\n    const value = this.map.get(key);  // 查找缓存数据\n    if (value === undefined) {  // 如果数据不存在，返回-1\n      return -1;\n    } else {  // 如果数据存在，将其从Map中删除并重新插入到Map的最后面\n      this.map.delete(key);\n      this.map.set(key, value);\n      return value;\n    }\n  }\n\n  put(key, value) {\n    if (this.map.has(key)) {  // 如果缓存数据已存在，将其从Map中删除\n      this.map.delete(key);\n    }\n    this.map.set(key, value);  // 插入新的缓存数据到Map的最后面\n    if (this.map.size > this.capacity) {  // 如果缓存容量已满，删除最近最少使用的缓存数据\n      const oldestKey = this.map.keys().next().value;  // 获取Map中第一个键，即最近最少使用的缓存数据的键\n      this.map.delete(oldestKey);\n    }\n  }\n}\n\n// 示例\nconst cache = new LRUCache(2);  // 初始化容量为2的LRU缓存\ncache.put(1, 1);\ncache.put(2, 2);\nconsole.log(cache.get(1));  // 1，因为缓存中存在键为1的数据\ncache.put(3, 3);  // 缓存容量已满，删除最近最少使用的缓存数据（键为2的数据）\nconsole.log(cache.get(2));  // -1，因为缓存中不存在键为2的数据\ncache.put(4, 4);  // 缓存容量已满，删除最近最少使用的缓存数据（键为1的数据）\nconsole.log(cache.get(1));  // -1，因为缓存中不存在键为1的数据\nconsole.log(cache.get(3));  // 3，因为缓存中存在键为3的数据\nconsole.log(cache.get(4));  // 4，因为缓存中存在键为4的数据\n```\n\n## 爬楼梯问题\n最基础的动态规划题，必须掌握。\n\n``` javascript\nfunction climbStairs(n) {\n  if (n <= 2) {  // 当n小于等于2时，有n种不同的爬楼梯方法\n    return n;\n  }\n  let a = 1, b = 2, c;\n  for (let i = 3; i <= n; i++) {  // 使用动态规划，计算n步爬楼梯的不同方法数\n    c = a + b;\n    a = b;\n    b = c;\n  }\n  return c;\n}\n\n// 示例\nconsole.log(climbStairs(2));  // 2，因为有两种不同的爬楼梯方法：一次爬1级或者一次爬2级\nconsole.log(climbStairs(3));  // 3，因为有三种不同的爬楼梯方法：一次爬1级、一次爬2级、或者一次爬1级再一次爬2级\nconsole.log(climbStairs(4));  // 5，因为有五种不同的爬楼梯方法：一次爬1级、一次爬2级、一次爬1级再一次爬2级、一次爬2级再一次爬2级、或者一次爬1级再一次爬1级再一次爬2级\n```\n\n## 斐波那契数列\n\n类似于爬楼梯问题，用动态规划。\n\n``` javascript\nfunction fibonacci(n) {\n  if (n === 0 || n === 1) {  // 当n等于0或1时，返回n\n    return n;\n  }\n  let a = 0, b = 1, c;\n  for (let i = 2; i <= n; i++) {  // 使用动态规划，计算斐波那契数列的第n项\n    c = a + b;\n    a = b;\n    b = c;\n  }\n  return c;\n}\n\n// 示例\nconsole.log(fibonacci(0));  // 0\nconsole.log(fibonacci(1));  // 1\nconsole.log(fibonacci(2));  // 1\nconsole.log(fibonacci(3));  // 2\nconsole.log(fibonacci(4));  // 3\n```\n\n## 遍历二叉树\n\n定义二叉树节点：\n\n``` javascript\n// 定义二叉树节点\nclass TreeNode {\n  constructor(val) {\n    this.val = val;\n    this.left = null;\n    this.right = null;\n  }\n}\n```\n\n前序遍历：\n\n``` javascript\n// 前序遍历\nfunction preorderTraversal(root) {\n  const res = [];  // 用于存储遍历结果\n  function preorder(root) {\n    if (!root) {\n      return;\n    }\n    res.push(root.val);\n    preorder(root.left);\n    preorder(root.right);\n  }\n  preorder(root);\n  return res;\n}\n// 示例\nconst root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(3);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(5);\n\nconsole.log(preorderTraversal(root));  // [1, 2, 4, 5, 3]\n```\n\n中序遍历：\n\n``` javascript\n// 中序遍历\nfunction inorderTraversal(root) {\n  const res = [];  // 用于存储遍历结果\n  function inorder(root) {\n    if (!root) {\n      return;\n    }\n    inorder(root.left);\n    res.push(root.val);\n    inorder(root.right);\n  }\n  inorder(root);\n  return res;\n}\n\n// 示例\nconst root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(3);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(5);\n\nconsole.log(inorderTraversal(root));   // [4, 2, 5, 1, 3]\n```\n\n后序遍历：\n\n``` javascript\n// 后序遍历\nfunction postorderTraversal(root) {\n  const res = [];  // 用于存储遍历结果\n  function postorder(root) {\n    if (!root) {\n      return;\n    }\n    postorder(root.left);\n    postorder(root.right);\n    res.push(root.val);\n  }\n  postorder(root);\n  return res;\n}\n\n// 示例\nconst root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(3);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(5);\n\nconsole.log(postorderTraversal(root)); // [4, 5, 2, 3, 1]\n```","slug":"interview-algorithm","html":"<h2>算法面试心得</h2>\n<p>关于算法面试，实在是没什么太好的捷径，如果想面试外企或者对算法要求比较高的企业，老老实实刷Leetcode就得了。</p>\n<p>对于怎么刷Leetcode，在这里给一些建议：</p>\n<ul>\n<li>分类刷题，比如动态规划、双指针、二叉树这些。刷多了你就会发现，同一个类型的题，解题套路和编码步骤都是类似的。</li>\n<li>尽量少刷难度为Hard的题，对于前端来说，面试中碰到Hard的算法题概率还是很低的，刷难度高的题一是收益不大，二是可能会打击你的信心。</li>\n<li>对于非计算机专业或者算法基础薄弱的同学，有空闲时间最好找一些课程系统地学习数据结构和算法，不然直接刷题会面临很多挑战。</li>\n<li>保持耐心别着急，贵在坚持，一周哪怕就刷两道题，只要消化了就好。</li>\n<li>实际上绝大多数企业包括大厂，其实对前端的算法能力要求并不会太高，一本《剑指Offer》足矣。</li>\n</ul>\n<h2>快排</h2>\n<p>最常见的基础算法，很多面试一上来就让写个快排，所以必须掌握。</p>\n<p>思路：把一个数组分成两个子数组来递归地解决问题，选择一个基准值，然后将小于等于基准值的元素移到数组左侧，将大于基准值的元素移到数组右侧，再对左右两个子数组递归进行排序，最终得到一个有序的数组。</p>\n<pre><code class=\"language-javascript\">function quickSort(arr) {\n  if (arr.length &#x3C;= 1) {  // 如果数组长度小于等于1，直接返回\n    return arr;\n  }\n  const pivotIndex = Math.floor(arr.length / 2);  // 选择基准值\n  const pivot = arr.splice(pivotIndex, 1)[0];  // 将基准值从数组中删除，并保存基准值\n  const left = [], right = [];\n  for (let i = 0; i &#x3C; arr.length; i++) {\n    if (arr[i] &#x3C; pivot) {  // 将小于基准值的元素放入左子数组\n      left.push(arr[i]);\n    } else {  // 将大于等于基准值的元素放入右子数组\n      right.push(arr[i]);\n    }\n  }\n  return quickSort(left).concat([pivot], quickSort(right));  // 对左右子数组递归进行排序，最终合并为一个有序数组\n}\n\n// 示例\nconst arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];\nconsole.log(quickSort(arr));  // [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]\n</code></pre>\n<h2>二分搜索</h2>\n<p>利用数组有序这一特点，将查找区间不断缩小一半，从而快速地定位目标元素。</p>\n<pre><code class=\"language-javascript\">function binarySearch(arr, target) {\n  let left = 0, right = arr.length - 1;\n  while (left &#x3C;= right) {  // 当查找区间非空时\n    const mid = Math.floor((left + right) / 2);  // 计算中间位置\n    if (arr[mid] === target) {  // 如果中间位置的元素就是目标元素，直接返回\n      return mid;\n    } else if (arr[mid] &#x3C; target) {  // 如果中间位置的元素小于目标元素，将查找区间缩小为右半部分\n      left = mid + 1;\n    } else {  // 如果中间位置的元素大于目标元素，将查找区间缩小为左半部分\n      right = mid - 1;\n    }\n  }\n  return -1;  // 如果没有找到目标元素，返回-1\n}\n\n// 示例\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nconsole.log(binarySearch(arr, 5));  // 4\nconsole.log(binarySearch(arr, 10));  // -1\n</code></pre>\n<h2>LRU缓存算法</h2>\n<p>有缓存的地方就有LRU，比如说Vue的keep-alive就是用的LRU缓存算法实现的。</p>\n<pre><code class=\"language-javascript\">class LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;  // 缓存容量\n    this.map = new Map();  // 使用Map来存储缓存数据，实现O(1)的查找和删除\n  }\n\n  get(key) {\n    const value = this.map.get(key);  // 查找缓存数据\n    if (value === undefined) {  // 如果数据不存在，返回-1\n      return -1;\n    } else {  // 如果数据存在，将其从Map中删除并重新插入到Map的最后面\n      this.map.delete(key);\n      this.map.set(key, value);\n      return value;\n    }\n  }\n\n  put(key, value) {\n    if (this.map.has(key)) {  // 如果缓存数据已存在，将其从Map中删除\n      this.map.delete(key);\n    }\n    this.map.set(key, value);  // 插入新的缓存数据到Map的最后面\n    if (this.map.size > this.capacity) {  // 如果缓存容量已满，删除最近最少使用的缓存数据\n      const oldestKey = this.map.keys().next().value;  // 获取Map中第一个键，即最近最少使用的缓存数据的键\n      this.map.delete(oldestKey);\n    }\n  }\n}\n\n// 示例\nconst cache = new LRUCache(2);  // 初始化容量为2的LRU缓存\ncache.put(1, 1);\ncache.put(2, 2);\nconsole.log(cache.get(1));  // 1，因为缓存中存在键为1的数据\ncache.put(3, 3);  // 缓存容量已满，删除最近最少使用的缓存数据（键为2的数据）\nconsole.log(cache.get(2));  // -1，因为缓存中不存在键为2的数据\ncache.put(4, 4);  // 缓存容量已满，删除最近最少使用的缓存数据（键为1的数据）\nconsole.log(cache.get(1));  // -1，因为缓存中不存在键为1的数据\nconsole.log(cache.get(3));  // 3，因为缓存中存在键为3的数据\nconsole.log(cache.get(4));  // 4，因为缓存中存在键为4的数据\n</code></pre>\n<h2>爬楼梯问题</h2>\n<p>最基础的动态规划题，必须掌握。</p>\n<pre><code class=\"language-javascript\">function climbStairs(n) {\n  if (n &#x3C;= 2) {  // 当n小于等于2时，有n种不同的爬楼梯方法\n    return n;\n  }\n  let a = 1, b = 2, c;\n  for (let i = 3; i &#x3C;= n; i++) {  // 使用动态规划，计算n步爬楼梯的不同方法数\n    c = a + b;\n    a = b;\n    b = c;\n  }\n  return c;\n}\n\n// 示例\nconsole.log(climbStairs(2));  // 2，因为有两种不同的爬楼梯方法：一次爬1级或者一次爬2级\nconsole.log(climbStairs(3));  // 3，因为有三种不同的爬楼梯方法：一次爬1级、一次爬2级、或者一次爬1级再一次爬2级\nconsole.log(climbStairs(4));  // 5，因为有五种不同的爬楼梯方法：一次爬1级、一次爬2级、一次爬1级再一次爬2级、一次爬2级再一次爬2级、或者一次爬1级再一次爬1级再一次爬2级\n</code></pre>\n<h2>斐波那契数列</h2>\n<p>类似于爬楼梯问题，用动态规划。</p>\n<pre><code class=\"language-javascript\">function fibonacci(n) {\n  if (n === 0 || n === 1) {  // 当n等于0或1时，返回n\n    return n;\n  }\n  let a = 0, b = 1, c;\n  for (let i = 2; i &#x3C;= n; i++) {  // 使用动态规划，计算斐波那契数列的第n项\n    c = a + b;\n    a = b;\n    b = c;\n  }\n  return c;\n}\n\n// 示例\nconsole.log(fibonacci(0));  // 0\nconsole.log(fibonacci(1));  // 1\nconsole.log(fibonacci(2));  // 1\nconsole.log(fibonacci(3));  // 2\nconsole.log(fibonacci(4));  // 3\n</code></pre>\n<h2>遍历二叉树</h2>\n<p>定义二叉树节点：</p>\n<pre><code class=\"language-javascript\">// 定义二叉树节点\nclass TreeNode {\n  constructor(val) {\n    this.val = val;\n    this.left = null;\n    this.right = null;\n  }\n}\n</code></pre>\n<p>前序遍历：</p>\n<pre><code class=\"language-javascript\">// 前序遍历\nfunction preorderTraversal(root) {\n  const res = [];  // 用于存储遍历结果\n  function preorder(root) {\n    if (!root) {\n      return;\n    }\n    res.push(root.val);\n    preorder(root.left);\n    preorder(root.right);\n  }\n  preorder(root);\n  return res;\n}\n// 示例\nconst root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(3);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(5);\n\nconsole.log(preorderTraversal(root));  // [1, 2, 4, 5, 3]\n</code></pre>\n<p>中序遍历：</p>\n<pre><code class=\"language-javascript\">// 中序遍历\nfunction inorderTraversal(root) {\n  const res = [];  // 用于存储遍历结果\n  function inorder(root) {\n    if (!root) {\n      return;\n    }\n    inorder(root.left);\n    res.push(root.val);\n    inorder(root.right);\n  }\n  inorder(root);\n  return res;\n}\n\n// 示例\nconst root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(3);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(5);\n\nconsole.log(inorderTraversal(root));   // [4, 2, 5, 1, 3]\n</code></pre>\n<p>后序遍历：</p>\n<pre><code class=\"language-javascript\">// 后序遍历\nfunction postorderTraversal(root) {\n  const res = [];  // 用于存储遍历结果\n  function postorder(root) {\n    if (!root) {\n      return;\n    }\n    postorder(root.left);\n    postorder(root.right);\n    res.push(root.val);\n  }\n  postorder(root);\n  return res;\n}\n\n// 示例\nconst root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(3);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(5);\n\nconsole.log(postorderTraversal(root)); // [4, 5, 2, 3, 1]\n</code></pre>\n"}},"__N_SSG":true}