<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>卡鲁秋 - 前端面试题汇总</title><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="4"/><meta charSet="utf-8"/><meta name="robots" content="follow, index"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><link rel="preload" href="/interview/_next/static/css/5518ada2dd4eaf66.css" as="style" crossorigin=""/><link rel="stylesheet" href="/interview/_next/static/css/5518ada2dd4eaf66.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/interview/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/interview/_next/static/chunks/webpack-b0a39061ef5434f8.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/framework-5429a50ba5373c56.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/main-846b70f57d3f15ee.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/pages/_app-9a697299b91baa3f.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/pages/%5Bslug%5D-e58918b5e268a43a.js" defer="" crossorigin=""></script><script src="/interview/_next/static/TpJ1laz5Lcbckz5SVJCNr/_buildManifest.js" defer="" crossorigin=""></script><script src="/interview/_next/static/TpJ1laz5Lcbckz5SVJCNr/_ssgManifest.js" defer="" crossorigin=""></script></head><body class="bg-white text-gray-700 antialiased"><div id="__next"><div class="flex h-full min-h-[100vh] w-full flex-col" style="flex-direction:column;min-height:100vh"><main class="flex flex-1 grow-[1] flex-col" style="flex:1"><div class="bg-white p-6"><div class="flex flex-col space-y-6"><article><header><h1 class="text-4xl font-bold"></h1></header><div></div></article></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"post":{"content":"## Nodejs适用于哪些场景？\n\n- 后端开发，Nodejs的异步I/O天生适合做Web高并发。\n- BFF开发，比如SSR中间层或者GraphQL中间层。\n- 前端基建，Webpack、Gulp、Babel、Jest等等前端工程化的工具或插件。\n\n## Nodejs的事件循环和浏览器有什么区别？\nNode.js 的事件循环和浏览器中的事件循环的区别在于，浏览器的异步任务分为宏任务队列和微任务队列，而Nodejs的异步任务分成了6个任务队列，按执行顺序分别为：\n\n1. **timers阶段**：处理setTimeout()和setInterval()等定时器事件。\n2. **I/O callbacks阶段**：处理几乎所有的异步I/O回调，例如网络I/O、文件I/O等。\n3. **idle, prepare阶段**：这是Node.js内部使用的，开发者很少会用到。\n4. **poll阶段**：等待新的I/O事件，处理已经完成的事件回调。\n5. **check阶段**：处理setImmediate()的回调函数。\n6. **close callbacks阶段**：处理一些关闭事件，例如socket关闭等。\n\n举个例子：\n\n``` javascript\nconsole.log('start');\n\nsetTimeout(() =\u003e {\n  console.log('timeout');\n}, 1000);\n\nsetImmediate(() =\u003e {\n  console.log('immediate');\n});\n\nconsole.log('end');\n```\n\n输出结果：\n\n```\nbash\nstart\nend\nimmediate\ntimeout\n```\n\n再来一个复杂的例子：\n\n``` javascript\nconsole.log('start');\n\nsetTimeout(() =\u003e {\n  console.log('timeout');\n  process.nextTick(() =\u003e {\n    console.log('nextTick');\n  });\n}, 1000);\n\nsetImmediate(() =\u003e {\n  console.log('immediate');\n});\n\nconst fs = require('fs');\nfs.readFile(__filename, () =\u003e {\n  console.log('readFile');\n  setImmediate(() =\u003e {\n    console.log('immediate in readFile callback');\n  });\n  setTimeout(() =\u003e {\n    console.log('timeout in readFile callback');\n  }, 0);\n});\n\nprocess.nextTick(() =\u003e {\n  console.log('nextTick');\n});\n\nconsole.log('end');\n```\n\n输出如下：\n\n```\nbash\nstart\nend\nnextTick\nreadFile\nnextTick\nimmediate\nimmediate in readFile callback\ntimeout in readFile callback\ntimeout\nnextTick\n```\n\n分析一下整个代码在事件循环的六个阶段中的执行顺序：\n\n1. **timers阶段**：在该阶段中，执行了由setTimeout方法产生的回调函数，输出`timeout`，并在回调函数中注册了一个`process.nextTick`方法产生的回调函数。\n2. **I/O callbacks阶段**：执行`fs.readFile`方法的回调函数，输出`readFile`，并在回调函数中注册了一个`setImmediate`和一个`setTimeout`方法产生的回调函数。\n3. **idle, prepare阶段**：没有任务执行。\n4. **poll阶段**：处理setImmediate方法产生的回调函数，输出`immediate`和`immediate in readFile callback`。然后处理由`fs.readFile`方法产生的setTimeout方法回调函数，输出`timeout in readFile callback`。\n5. **check阶段**：在该阶段中，执行由`process.nextTick`方法产生的回调函数，输出`nextTick`和`nextTick`。\n6. **close callbacks阶段**：没有任务执行。\n\n## 讲一下EventEmitter？\n\nEventEmitter经常在面试的时候会要求手写，因为这玩意用途实在是太广了。比如在Vue里面的EventBus实现组件通信，其核心就是EventEmitter。\n\nNode.js 的大多数核心模块都是基于EventEmitter开发的，如 http、net、fs，很多第三方库也是基于EventEmitter开发的，如socket.io、nodemailercheerio等。\n\n使用EventEmitter的好处是可以用事件的形式来处理异步任务，可以大大简化代码，并且容易处理异常。\n\n举个例子来看看为什么Nodejs里大多数模块都要继承EventEmitter。\n\n这是不使用EventEmitter的on方法来实现文件读取：\n\n``` javascript\nconst fs = require('fs');\n\nfs.readFile('file.txt', (err, data) =\u003e {\n  if (err) {\n    console.error(`Failed to read file: ${err}`);\n  } else {\n    console.log(`File content: ${data}`);\n  }\n});\n```\n\n这是使用EventEmitter的读取文件：\n\n``` javascript\nconst fs = require('fs');\n\nconst stream = fs.createReadStream('file.txt');\n\nstream.on('data', (chunk) =\u003e {\n  console.log(`Received ${chunk.length} bytes of data.`);\n});\n\nstream.on('end', () =\u003e {\n  console.log('Finished reading file.');\n});\n```\n\n很显然，如果我们不使用EventEmitter，如果在读取完成后执行多个回调函数，就需要手动创建回调函数数组，并将每个回调函数都添加到数组中，这样代码就会变得复杂。\n\n## Buffer怎么理解，有什么应用？\nBuffer对象是一个类似于数组的对象，它的每个元素都是一个表示 8 位字节的整数。\n\n可以将其看作是一个字节数组，用来存储和操作二进制数据。\n\n应用场景：\n\n1. 网络通信：可以使用Buffer.from()方法将字符串转换为二进制数据，然后使用net模块进行网络通信：\n\n``` javascript\nconst net = require('net');\n\nconst client = net.createConnection({ port: 8080 }, () =\u003e {\n  // 将字符串转换为二进制数据\n  const data = Buffer.from('Hello, world!', 'utf8');\n\n  // 发送数据\n  client.write(data);\n});\n```\n\n2. 文件操作，用Buffer来存储文件数据：\n\n``` javascript\nconst fs = require('fs');\n\n// 读取文件，并将数据存储到 Buffer 对象中\nconst data = fs.readFileSync('/path/to/file');\n\n// 处理数据\n// ...\n```\n\n3. 加密解密，例如，可以使用 crypto 模块创建加密解密算法需要的二进制数据：\n\n``` javascript\nconst crypto = require('crypto');\n\n// 创建加密解密算法需要的二进制数据\nconst key = Buffer.from('mysecretkey', 'utf8');\nconst iv = Buffer.alloc(16);\n\n// 创建加密解密算法对象\nconst cipher = crypto.createCipheriv('aes-256-cbc', key, iv);\n\n// 加密数据\nconst encrypted = Buffer.concat([cipher.update(data), cipher.final()]);\n```\n\n4. 图像处理：\n\n``` javascript\nconst fs = require('fs');\nconst sharp = require('sharp');\n\n// 读取图片文件，并将数据存储到 Buffer 对象中\nconst data = fs.readFileSync('/path/to/image');\n\n// 处理图片\nsharp(data)\n  .resize(200, 200)\n  .toFile('/path/to/resized-image', (err, info) =\u003e {\n    // ...\n  });\n```\n\n## 什么是I/O？\n\n**概念**：计算机里所谓的I/O指的是输入和输出，但对于前端同学而言，这个定义可能不太好理解。简单点说，需要等待的任务都可以称为I/O任务，比如前端的事件处理、网络请求、定时器，后端的文件处理、网络请求、数据库操作，这些都属于I/O任务。\n\n**异步I/O**：以网络请求任务为例，传统的同步I/O指的是一个一个排队执行，一个执行完了再执行下一个，即使线程空闲，也不能执行其他任务。\n\nNodejs的异步I/O会返回一个标记，告诉调用者 I/O 操作已经开始，但不会阻塞线程。当 I/O 操作完成时，Node.js 会调用注册的回调函数，将结果返回给调用者。\n\n这种方式使得程序在执行 I/O 操作时不必等待，而可以继续执行其他任务，提高了程序的并发性能。\n\n### 听起来异步I/O很好，那为什么同步I/O依然会存在？\n\n- 传统的同步I/O操作比异步I/O操作更容易理解和编写。异步编程需要开发人员具备较高的技能水平，以及对事件循环、回调函数等概念的深入理解。\n- 对于某些小规模的应用程序或者一些低频次的I/O操作，使用异步I/O可能不会带来很大的性能提升，而且可能会增加代码的复杂性。\n- 对于一些CPU密集型任务，传统I/O操作可能比异步I/O更快，因为异步I/O 会在I/O操作执行期间增加额外的上下文切换和事件处理负担，从而降低了程序的性能。\n\n### CPU密集和I/O密集：\n\n- CPU密集任务指的是纯计算任务。\n- I/O密集的任务指的是需要等待的任务。所谓的高并发，显然属于I/O密集型任务。\n\n## 讲一下常见的Nodejs框架？\n\n- **Koa**：一个轻量的Nodejs框架，代码非常简洁。采用洋葱圈模型中间件，非常方便扩展功能，但是开发后端API需要进行再封装。\n\n- **Express**：Express也是一个轻量框架，Express和Koa的区别在于中间件机制。但总体差别不是很大，绝大多数Nodejs框架都是在Koa或者Express基础上封装的。\n\n- **Eggjs**：基于Koa封装的框架，整合了数据库、路由、安全防护、日志记录、异常处理等中间件，可以用来快速开发Rest或者Restful API项目。\n\n- **Nestjs**：基于TS,使用了大量的装饰器语法，开发体验类似于Java的Springboot。除此之外，Nestjs还提供了GraphQL、WebSocket、各种MQ和微服务的解决方案，比较适合大型后端项目的开发。\n\n## Koa中间件原理了解吗？\n\nKoa的洋葱圈中间件实现原理主要有以下两点：\n\n1. 数组里面存函数：使用middleware来存储中间函数。\n\n``` javascript\nuse (fn) {\n  if (typeof fn !== 'function') throw new TypeError('middleware must be a function!')\n  debug('use %s', fn._name || fn.name || '-')\n  this.middleware.push(fn)\n  return this\n}\n```\n\n2. compose函数：将一组中间件函数组合成一个大的异步函数。这个大的异步函数会依次执行每个中间件函数，并将每个中间件函数的执行结果传递给下一个中间件函数。最终，这个大的异步函数会返回一个Promise对象，表示整个中间件链的执行结果。\n\n``` javascript\nfunction compose(middleware) {\n  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')\n  for (const fn of middleware) {\n    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')\n  }\n\n  return function (context, next) {\n    let index = -1\n    return dispatch(0)\n\n    function dispatch(i) {\n      if (i \u003c= index) return Promise.reject(new Error('next() called multiple times'))\n      index = i\n      let fn = middleware[i]\n      if (i === middleware.length) fn = next\n      if (!fn) return Promise.resolve()\n      try {\n        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)))\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n```\n\n## 什么是Stream流，有哪些应用场景？\n\nStream是一种处理流式数据的抽象接口，用于读取、写入、转换和操作数据流。它是一个基于事件的 API，可以让我们以高效、低延迟的方式处理大型数据集。\n\n说直白点就是基于Stream封装的API，性能更好。\n\n比如读取文件，使用流我们可以一点一点来读取文件，每次只读取或写入文件的一小部分数据块，而不是一次性将整个文件读取或写入到内存中或磁盘中，这样做能够降低内存占用。\n\n## 什么是BFF？\n\nBFF（Backend For Frontend）,说白了就是中间层，由前端同学开发的后端项目。\n\n最常见的BFF项目像SSR和GraphQL。SSR用来解决SEO问题，GraphQL用来聚合数据，解决API查询的问题。\n\n## 什么是ORM？Nodejs的ORM框架有哪些？\n\n操作数据库需要写很多SQL语句，ORM框架通过对SQL语句进行封装。然后将数据库的表格和用户代码里的模型对象，进行映射，这样用户只需要调用模型对象的方法就能实现数据库的增删改查。\n\nNode.js中比较流行的ORM框架有：\n\n1. **Sequelize**：Sequelize是一个基于Promise的ORM框架，支持MySQL、PostgreSQL、SQLite和Microsoft SQL Server等多种关系型数据库。它提供了丰富的API，可以轻松地进行数据模型定义、查询构建、事务管理等操作。\n\n2. **TypeORM**：TypeORM是一个基于TypeScript的ORM框架，支持MySQL、PostgreSQL、SQLite、Microsoft SQL Server和Oracle等多种关系型数据库。它提供了基于装饰器的实体定义和关系映射，支持事务、查询构建和关系处理等高级功能。\n\n## 有没有了解过Redis？\n\n可以从以下方面来回答：\n\n1. 用Redis实现缓存：将热门数据和热门页面存到Redis进行缓存，比如热门商品信息，商品页面和网站首页。\n2. 缓存遇到的问题：缓存穿透、缓存雪崩、缓存击穿。\n3. Redis的进阶功能：Redis有各种数据结构，除了缓存之外，还能实现很多功能。比如：消息队列、附近的人、排行榜等等。\n4. Redis持久化：Redis可以将缓存持久化到本地，持久化策略包括RDB和AOF。\n5. 集群：如果单机Redis不够用的话，可以考虑搭建Redis集群，Redis集群有主从和哨兵两种模式。\n\n\n## 有没有做过数据库优化？\n\n常见的优化有：\n\n1. 使用explain执行计划查看SQL的执行信息，进而定位慢SQL来源。\n2. 索引是Mysql调优首先能想到的方案，合理设置索引可以很大程度上提高查询效率。\n3. 大分页也是一个常见的性能问题出现的地方，因为MySQL需要扫描大量的数据，造成性能瓶颈。可以通过使用主键或者游标分页的方式来优化。\n4. 读写分离，单机顶不住的时候，可以使用主从架构，把数据库读写分担到不同的机器上。\n5. 分库分表，如果数据表存了海量数据，除了读写分离之外，还要考虑分库分表，把一张表分成多张表，减轻数据库压力。\n\n## 有了解过分布式和微服务吗？\n当单体应用撑不住的时候，就得考虑上集群，把应用部署在多个机器上，就形成了分布式架构。\n\n分布式的集群不仅带来了算力和并发能力，也带来了各种问题，这其中包括：分布式通信、分布式事务、分布式id、分布式容错、负载均衡等。\n\n所以就需要有各种中间件来解决这些问题，比如Nginx、Zookeeper、Dubbo、MQ、RPC等。\n\n然后当项目规模进一步扩大的时候，不仅要考虑集群，还要考虑项目的拆分，这时候就要上微服务架构了。把一个大项目根据业务拆分成很多功能单一的模块，可以由不同的团队独立开发和部署。\n\n比如一个电商的后台API，可以拆分成用户服务、商品服务、订单服务、优惠券服务、广告服务，这些服务由不同的团队去维护。\n\n当然，微服务也带来了更多的复杂性，所以就会有像Spring Cloud、Spring Cloud Alibaba这样的解决方案去解决这些复杂性。\n","slug":"interview-node","html":"\u003ch2\u003eNodejs适用于哪些场景？\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e后端开发，Nodejs的异步I/O天生适合做Web高并发。\u003c/li\u003e\n\u003cli\u003eBFF开发，比如SSR中间层或者GraphQL中间层。\u003c/li\u003e\n\u003cli\u003e前端基建，Webpack、Gulp、Babel、Jest等等前端工程化的工具或插件。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eNodejs的事件循环和浏览器有什么区别？\u003c/h2\u003e\n\u003cp\u003eNode.js 的事件循环和浏览器中的事件循环的区别在于，浏览器的异步任务分为宏任务队列和微任务队列，而Nodejs的异步任务分成了6个任务队列，按执行顺序分别为：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003etimers阶段\u003c/strong\u003e：处理setTimeout()和setInterval()等定时器事件。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eI/O callbacks阶段\u003c/strong\u003e：处理几乎所有的异步I/O回调，例如网络I/O、文件I/O等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eidle, prepare阶段\u003c/strong\u003e：这是Node.js内部使用的，开发者很少会用到。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003epoll阶段\u003c/strong\u003e：等待新的I/O事件，处理已经完成的事件回调。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003echeck阶段\u003c/strong\u003e：处理setImmediate()的回调函数。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eclose callbacks阶段\u003c/strong\u003e：处理一些关闭事件，例如socket关闭等。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e举个例子：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econsole.log('start');\n\nsetTimeout(() =\u003e {\n  console.log('timeout');\n}, 1000);\n\nsetImmediate(() =\u003e {\n  console.log('immediate');\n});\n\nconsole.log('end');\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e输出结果：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ebash\nstart\nend\nimmediate\ntimeout\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e再来一个复杂的例子：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econsole.log('start');\n\nsetTimeout(() =\u003e {\n  console.log('timeout');\n  process.nextTick(() =\u003e {\n    console.log('nextTick');\n  });\n}, 1000);\n\nsetImmediate(() =\u003e {\n  console.log('immediate');\n});\n\nconst fs = require('fs');\nfs.readFile(__filename, () =\u003e {\n  console.log('readFile');\n  setImmediate(() =\u003e {\n    console.log('immediate in readFile callback');\n  });\n  setTimeout(() =\u003e {\n    console.log('timeout in readFile callback');\n  }, 0);\n});\n\nprocess.nextTick(() =\u003e {\n  console.log('nextTick');\n});\n\nconsole.log('end');\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e输出如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ebash\nstart\nend\nnextTick\nreadFile\nnextTick\nimmediate\nimmediate in readFile callback\ntimeout in readFile callback\ntimeout\nnextTick\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e分析一下整个代码在事件循环的六个阶段中的执行顺序：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003etimers阶段\u003c/strong\u003e：在该阶段中，执行了由setTimeout方法产生的回调函数，输出\u003ccode\u003etimeout\u003c/code\u003e，并在回调函数中注册了一个\u003ccode\u003eprocess.nextTick\u003c/code\u003e方法产生的回调函数。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eI/O callbacks阶段\u003c/strong\u003e：执行\u003ccode\u003efs.readFile\u003c/code\u003e方法的回调函数，输出\u003ccode\u003ereadFile\u003c/code\u003e，并在回调函数中注册了一个\u003ccode\u003esetImmediate\u003c/code\u003e和一个\u003ccode\u003esetTimeout\u003c/code\u003e方法产生的回调函数。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eidle, prepare阶段\u003c/strong\u003e：没有任务执行。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003epoll阶段\u003c/strong\u003e：处理setImmediate方法产生的回调函数，输出\u003ccode\u003eimmediate\u003c/code\u003e和\u003ccode\u003eimmediate in readFile callback\u003c/code\u003e。然后处理由\u003ccode\u003efs.readFile\u003c/code\u003e方法产生的setTimeout方法回调函数，输出\u003ccode\u003etimeout in readFile callback\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003echeck阶段\u003c/strong\u003e：在该阶段中，执行由\u003ccode\u003eprocess.nextTick\u003c/code\u003e方法产生的回调函数，输出\u003ccode\u003enextTick\u003c/code\u003e和\u003ccode\u003enextTick\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eclose callbacks阶段\u003c/strong\u003e：没有任务执行。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e讲一下EventEmitter？\u003c/h2\u003e\n\u003cp\u003eEventEmitter经常在面试的时候会要求手写，因为这玩意用途实在是太广了。比如在Vue里面的EventBus实现组件通信，其核心就是EventEmitter。\u003c/p\u003e\n\u003cp\u003eNode.js 的大多数核心模块都是基于EventEmitter开发的，如 http、net、fs，很多第三方库也是基于EventEmitter开发的，如socket.io、nodemailercheerio等。\u003c/p\u003e\n\u003cp\u003e使用EventEmitter的好处是可以用事件的形式来处理异步任务，可以大大简化代码，并且容易处理异常。\u003c/p\u003e\n\u003cp\u003e举个例子来看看为什么Nodejs里大多数模块都要继承EventEmitter。\u003c/p\u003e\n\u003cp\u003e这是不使用EventEmitter的on方法来实现文件读取：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst fs = require('fs');\n\nfs.readFile('file.txt', (err, data) =\u003e {\n  if (err) {\n    console.error(`Failed to read file: ${err}`);\n  } else {\n    console.log(`File content: ${data}`);\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这是使用EventEmitter的读取文件：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst fs = require('fs');\n\nconst stream = fs.createReadStream('file.txt');\n\nstream.on('data', (chunk) =\u003e {\n  console.log(`Received ${chunk.length} bytes of data.`);\n});\n\nstream.on('end', () =\u003e {\n  console.log('Finished reading file.');\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e很显然，如果我们不使用EventEmitter，如果在读取完成后执行多个回调函数，就需要手动创建回调函数数组，并将每个回调函数都添加到数组中，这样代码就会变得复杂。\u003c/p\u003e\n\u003ch2\u003eBuffer怎么理解，有什么应用？\u003c/h2\u003e\n\u003cp\u003eBuffer对象是一个类似于数组的对象，它的每个元素都是一个表示 8 位字节的整数。\u003c/p\u003e\n\u003cp\u003e可以将其看作是一个字节数组，用来存储和操作二进制数据。\u003c/p\u003e\n\u003cp\u003e应用场景：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e网络通信：可以使用Buffer.from()方法将字符串转换为二进制数据，然后使用net模块进行网络通信：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst net = require('net');\n\nconst client = net.createConnection({ port: 8080 }, () =\u003e {\n  // 将字符串转换为二进制数据\n  const data = Buffer.from('Hello, world!', 'utf8');\n\n  // 发送数据\n  client.write(data);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e文件操作，用Buffer来存储文件数据：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst fs = require('fs');\n\n// 读取文件，并将数据存储到 Buffer 对象中\nconst data = fs.readFileSync('/path/to/file');\n\n// 处理数据\n// ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e加密解密，例如，可以使用 crypto 模块创建加密解密算法需要的二进制数据：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst crypto = require('crypto');\n\n// 创建加密解密算法需要的二进制数据\nconst key = Buffer.from('mysecretkey', 'utf8');\nconst iv = Buffer.alloc(16);\n\n// 创建加密解密算法对象\nconst cipher = crypto.createCipheriv('aes-256-cbc', key, iv);\n\n// 加密数据\nconst encrypted = Buffer.concat([cipher.update(data), cipher.final()]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e图像处理：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst fs = require('fs');\nconst sharp = require('sharp');\n\n// 读取图片文件，并将数据存储到 Buffer 对象中\nconst data = fs.readFileSync('/path/to/image');\n\n// 处理图片\nsharp(data)\n  .resize(200, 200)\n  .toFile('/path/to/resized-image', (err, info) =\u003e {\n    // ...\n  });\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e什么是I/O？\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e概念\u003c/strong\u003e：计算机里所谓的I/O指的是输入和输出，但对于前端同学而言，这个定义可能不太好理解。简单点说，需要等待的任务都可以称为I/O任务，比如前端的事件处理、网络请求、定时器，后端的文件处理、网络请求、数据库操作，这些都属于I/O任务。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e异步I/O\u003c/strong\u003e：以网络请求任务为例，传统的同步I/O指的是一个一个排队执行，一个执行完了再执行下一个，即使线程空闲，也不能执行其他任务。\u003c/p\u003e\n\u003cp\u003eNodejs的异步I/O会返回一个标记，告诉调用者 I/O 操作已经开始，但不会阻塞线程。当 I/O 操作完成时，Node.js 会调用注册的回调函数，将结果返回给调用者。\u003c/p\u003e\n\u003cp\u003e这种方式使得程序在执行 I/O 操作时不必等待，而可以继续执行其他任务，提高了程序的并发性能。\u003c/p\u003e\n\u003ch3\u003e听起来异步I/O很好，那为什么同步I/O依然会存在？\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e传统的同步I/O操作比异步I/O操作更容易理解和编写。异步编程需要开发人员具备较高的技能水平，以及对事件循环、回调函数等概念的深入理解。\u003c/li\u003e\n\u003cli\u003e对于某些小规模的应用程序或者一些低频次的I/O操作，使用异步I/O可能不会带来很大的性能提升，而且可能会增加代码的复杂性。\u003c/li\u003e\n\u003cli\u003e对于一些CPU密集型任务，传统I/O操作可能比异步I/O更快，因为异步I/O 会在I/O操作执行期间增加额外的上下文切换和事件处理负担，从而降低了程序的性能。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eCPU密集和I/O密集：\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eCPU密集任务指的是纯计算任务。\u003c/li\u003e\n\u003cli\u003eI/O密集的任务指的是需要等待的任务。所谓的高并发，显然属于I/O密集型任务。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e讲一下常见的Nodejs框架？\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eKoa\u003c/strong\u003e：一个轻量的Nodejs框架，代码非常简洁。采用洋葱圈模型中间件，非常方便扩展功能，但是开发后端API需要进行再封装。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eExpress\u003c/strong\u003e：Express也是一个轻量框架，Express和Koa的区别在于中间件机制。但总体差别不是很大，绝大多数Nodejs框架都是在Koa或者Express基础上封装的。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eEggjs\u003c/strong\u003e：基于Koa封装的框架，整合了数据库、路由、安全防护、日志记录、异常处理等中间件，可以用来快速开发Rest或者Restful API项目。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eNestjs\u003c/strong\u003e：基于TS,使用了大量的装饰器语法，开发体验类似于Java的Springboot。除此之外，Nestjs还提供了GraphQL、WebSocket、各种MQ和微服务的解决方案，比较适合大型后端项目的开发。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eKoa中间件原理了解吗？\u003c/h2\u003e\n\u003cp\u003eKoa的洋葱圈中间件实现原理主要有以下两点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e数组里面存函数：使用middleware来存储中间函数。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003euse (fn) {\n  if (typeof fn !== 'function') throw new TypeError('middleware must be a function!')\n  debug('use %s', fn._name || fn.name || '-')\n  this.middleware.push(fn)\n  return this\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003ecompose函数：将一组中间件函数组合成一个大的异步函数。这个大的异步函数会依次执行每个中间件函数，并将每个中间件函数的执行结果传递给下一个中间件函数。最终，这个大的异步函数会返回一个Promise对象，表示整个中间件链的执行结果。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction compose(middleware) {\n  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')\n  for (const fn of middleware) {\n    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')\n  }\n\n  return function (context, next) {\n    let index = -1\n    return dispatch(0)\n\n    function dispatch(i) {\n      if (i \u0026#x3C;= index) return Promise.reject(new Error('next() called multiple times'))\n      index = i\n      let fn = middleware[i]\n      if (i === middleware.length) fn = next\n      if (!fn) return Promise.resolve()\n      try {\n        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)))\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e什么是Stream流，有哪些应用场景？\u003c/h2\u003e\n\u003cp\u003eStream是一种处理流式数据的抽象接口，用于读取、写入、转换和操作数据流。它是一个基于事件的 API，可以让我们以高效、低延迟的方式处理大型数据集。\u003c/p\u003e\n\u003cp\u003e说直白点就是基于Stream封装的API，性能更好。\u003c/p\u003e\n\u003cp\u003e比如读取文件，使用流我们可以一点一点来读取文件，每次只读取或写入文件的一小部分数据块，而不是一次性将整个文件读取或写入到内存中或磁盘中，这样做能够降低内存占用。\u003c/p\u003e\n\u003ch2\u003e什么是BFF？\u003c/h2\u003e\n\u003cp\u003eBFF（Backend For Frontend）,说白了就是中间层，由前端同学开发的后端项目。\u003c/p\u003e\n\u003cp\u003e最常见的BFF项目像SSR和GraphQL。SSR用来解决SEO问题，GraphQL用来聚合数据，解决API查询的问题。\u003c/p\u003e\n\u003ch2\u003e什么是ORM？Nodejs的ORM框架有哪些？\u003c/h2\u003e\n\u003cp\u003e操作数据库需要写很多SQL语句，ORM框架通过对SQL语句进行封装。然后将数据库的表格和用户代码里的模型对象，进行映射，这样用户只需要调用模型对象的方法就能实现数据库的增删改查。\u003c/p\u003e\n\u003cp\u003eNode.js中比较流行的ORM框架有：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eSequelize\u003c/strong\u003e：Sequelize是一个基于Promise的ORM框架，支持MySQL、PostgreSQL、SQLite和Microsoft SQL Server等多种关系型数据库。它提供了丰富的API，可以轻松地进行数据模型定义、查询构建、事务管理等操作。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eTypeORM\u003c/strong\u003e：TypeORM是一个基于TypeScript的ORM框架，支持MySQL、PostgreSQL、SQLite、Microsoft SQL Server和Oracle等多种关系型数据库。它提供了基于装饰器的实体定义和关系映射，支持事务、查询构建和关系处理等高级功能。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e有没有了解过Redis？\u003c/h2\u003e\n\u003cp\u003e可以从以下方面来回答：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e用Redis实现缓存：将热门数据和热门页面存到Redis进行缓存，比如热门商品信息，商品页面和网站首页。\u003c/li\u003e\n\u003cli\u003e缓存遇到的问题：缓存穿透、缓存雪崩、缓存击穿。\u003c/li\u003e\n\u003cli\u003eRedis的进阶功能：Redis有各种数据结构，除了缓存之外，还能实现很多功能。比如：消息队列、附近的人、排行榜等等。\u003c/li\u003e\n\u003cli\u003eRedis持久化：Redis可以将缓存持久化到本地，持久化策略包括RDB和AOF。\u003c/li\u003e\n\u003cli\u003e集群：如果单机Redis不够用的话，可以考虑搭建Redis集群，Redis集群有主从和哨兵两种模式。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e有没有做过数据库优化？\u003c/h2\u003e\n\u003cp\u003e常见的优化有：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e使用explain执行计划查看SQL的执行信息，进而定位慢SQL来源。\u003c/li\u003e\n\u003cli\u003e索引是Mysql调优首先能想到的方案，合理设置索引可以很大程度上提高查询效率。\u003c/li\u003e\n\u003cli\u003e大分页也是一个常见的性能问题出现的地方，因为MySQL需要扫描大量的数据，造成性能瓶颈。可以通过使用主键或者游标分页的方式来优化。\u003c/li\u003e\n\u003cli\u003e读写分离，单机顶不住的时候，可以使用主从架构，把数据库读写分担到不同的机器上。\u003c/li\u003e\n\u003cli\u003e分库分表，如果数据表存了海量数据，除了读写分离之外，还要考虑分库分表，把一张表分成多张表，减轻数据库压力。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e有了解过分布式和微服务吗？\u003c/h2\u003e\n\u003cp\u003e当单体应用撑不住的时候，就得考虑上集群，把应用部署在多个机器上，就形成了分布式架构。\u003c/p\u003e\n\u003cp\u003e分布式的集群不仅带来了算力和并发能力，也带来了各种问题，这其中包括：分布式通信、分布式事务、分布式id、分布式容错、负载均衡等。\u003c/p\u003e\n\u003cp\u003e所以就需要有各种中间件来解决这些问题，比如Nginx、Zookeeper、Dubbo、MQ、RPC等。\u003c/p\u003e\n\u003cp\u003e然后当项目规模进一步扩大的时候，不仅要考虑集群，还要考虑项目的拆分，这时候就要上微服务架构了。把一个大项目根据业务拆分成很多功能单一的模块，可以由不同的团队独立开发和部署。\u003c/p\u003e\n\u003cp\u003e比如一个电商的后台API，可以拆分成用户服务、商品服务、订单服务、优惠券服务、广告服务，这些服务由不同的团队去维护。\u003c/p\u003e\n\u003cp\u003e当然，微服务也带来了更多的复杂性，所以就会有像Spring Cloud、Spring Cloud Alibaba这样的解决方案去解决这些复杂性。\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/[slug]","query":{"slug":"interview-node"},"buildId":"TpJ1laz5Lcbckz5SVJCNr","assetPrefix":"/interview","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>