<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>卡鲁秋 - 前端面试题汇总</title><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="4"/><meta charSet="utf-8"/><meta name="robots" content="follow, index"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><link rel="preload" href="/interview/_next/static/css/5518ada2dd4eaf66.css" as="style" crossorigin=""/><link rel="stylesheet" href="/interview/_next/static/css/5518ada2dd4eaf66.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/interview/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/interview/_next/static/chunks/webpack-b0a39061ef5434f8.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/framework-5429a50ba5373c56.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/main-846b70f57d3f15ee.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/pages/_app-9a697299b91baa3f.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/pages/%5Bslug%5D-e58918b5e268a43a.js" defer="" crossorigin=""></script><script src="/interview/_next/static/d2zJ11P1rS-26pC0W69Ok/_buildManifest.js" defer="" crossorigin=""></script><script src="/interview/_next/static/d2zJ11P1rS-26pC0W69Ok/_ssgManifest.js" defer="" crossorigin=""></script></head><body class="bg-white text-gray-700 antialiased"><div id="__next"><div class="flex h-full min-h-[100vh] w-full flex-col" style="flex-direction:column;min-height:100vh"><main class="flex flex-1 grow-[1] flex-col" style="flex:1"><div class="bg-white p-6"><div class="flex flex-col space-y-6"><article><header><h1 class="text-4xl font-bold"></h1></header><div></div></article></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"post":{"content":"## 算法面试心得\n\n关于算法面试，实在是没什么太好的捷径，如果想面试外企或者对算法要求比较高的企业，老老实实刷Leetcode就得了。\n\n对于怎么刷Leetcode，在这里给一些建议：\n\n- 分类刷题，比如动态规划、双指针、二叉树这些。刷多了你就会发现，同一个类型的题，解题套路和编码步骤都是类似的。\n- 尽量少刷难度为Hard的题，对于前端来说，面试中碰到Hard的算法题概率还是很低的，刷难度高的题一是收益不大，二是可能会打击你的信心。\n- 对于非计算机专业或者算法基础薄弱的同学，有空闲时间最好找一些课程系统地学习数据结构和算法，不然直接刷题会面临很多挑战。\n- 保持耐心别着急，贵在坚持，一周哪怕就刷两道题，只要消化了就好。\n- 实际上绝大多数企业包括大厂，其实对前端的算法能力要求并不会太高，一本《剑指Offer》足矣。\n\n## 快排\n最常见的基础算法，很多面试一上来就让写个快排，所以必须掌握。\n\n思路：把一个数组分成两个子数组来递归地解决问题，选择一个基准值，然后将小于等于基准值的元素移到数组左侧，将大于基准值的元素移到数组右侧，再对左右两个子数组递归进行排序，最终得到一个有序的数组。\n\n``` javascript\nfunction quickSort(arr) {\n  if (arr.length \u003c= 1) {  // 如果数组长度小于等于1，直接返回\n    return arr;\n  }\n  const pivotIndex = Math.floor(arr.length / 2);  // 选择基准值\n  const pivot = arr.splice(pivotIndex, 1)[0];  // 将基准值从数组中删除，并保存基准值\n  const left = [], right = [];\n  for (let i = 0; i \u003c arr.length; i++) {\n    if (arr[i] \u003c pivot) {  // 将小于基准值的元素放入左子数组\n      left.push(arr[i]);\n    } else {  // 将大于等于基准值的元素放入右子数组\n      right.push(arr[i]);\n    }\n  }\n  return quickSort(left).concat([pivot], quickSort(right));  // 对左右子数组递归进行排序，最终合并为一个有序数组\n}\n\n// 示例\nconst arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];\nconsole.log(quickSort(arr));  // [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]\n```\n\n## 二分搜索\n利用数组有序这一特点，将查找区间不断缩小一半，从而快速地定位目标元素。\n\n``` javascript\nfunction binarySearch(arr, target) {\n  let left = 0, right = arr.length - 1;\n  while (left \u003c= right) {  // 当查找区间非空时\n    const mid = Math.floor((left + right) / 2);  // 计算中间位置\n    if (arr[mid] === target) {  // 如果中间位置的元素就是目标元素，直接返回\n      return mid;\n    } else if (arr[mid] \u003c target) {  // 如果中间位置的元素小于目标元素，将查找区间缩小为右半部分\n      left = mid + 1;\n    } else {  // 如果中间位置的元素大于目标元素，将查找区间缩小为左半部分\n      right = mid - 1;\n    }\n  }\n  return -1;  // 如果没有找到目标元素，返回-1\n}\n\n// 示例\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nconsole.log(binarySearch(arr, 5));  // 4\nconsole.log(binarySearch(arr, 10));  // -1\n```\n\n## LRU缓存算法\n\n有缓存的地方就有LRU，比如说Vue的keep-alive就是用的LRU缓存算法实现的。\n\n``` javascript\nclass LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;  // 缓存容量\n    this.map = new Map();  // 使用Map来存储缓存数据，实现O(1)的查找和删除\n  }\n\n  get(key) {\n    const value = this.map.get(key);  // 查找缓存数据\n    if (value === undefined) {  // 如果数据不存在，返回-1\n      return -1;\n    } else {  // 如果数据存在，将其从Map中删除并重新插入到Map的最后面\n      this.map.delete(key);\n      this.map.set(key, value);\n      return value;\n    }\n  }\n\n  put(key, value) {\n    if (this.map.has(key)) {  // 如果缓存数据已存在，将其从Map中删除\n      this.map.delete(key);\n    }\n    this.map.set(key, value);  // 插入新的缓存数据到Map的最后面\n    if (this.map.size \u003e this.capacity) {  // 如果缓存容量已满，删除最近最少使用的缓存数据\n      const oldestKey = this.map.keys().next().value;  // 获取Map中第一个键，即最近最少使用的缓存数据的键\n      this.map.delete(oldestKey);\n    }\n  }\n}\n\n// 示例\nconst cache = new LRUCache(2);  // 初始化容量为2的LRU缓存\ncache.put(1, 1);\ncache.put(2, 2);\nconsole.log(cache.get(1));  // 1，因为缓存中存在键为1的数据\ncache.put(3, 3);  // 缓存容量已满，删除最近最少使用的缓存数据（键为2的数据）\nconsole.log(cache.get(2));  // -1，因为缓存中不存在键为2的数据\ncache.put(4, 4);  // 缓存容量已满，删除最近最少使用的缓存数据（键为1的数据）\nconsole.log(cache.get(1));  // -1，因为缓存中不存在键为1的数据\nconsole.log(cache.get(3));  // 3，因为缓存中存在键为3的数据\nconsole.log(cache.get(4));  // 4，因为缓存中存在键为4的数据\n```\n\n## 爬楼梯问题\n最基础的动态规划题，必须掌握。\n\n``` javascript\nfunction climbStairs(n) {\n  if (n \u003c= 2) {  // 当n小于等于2时，有n种不同的爬楼梯方法\n    return n;\n  }\n  let a = 1, b = 2, c;\n  for (let i = 3; i \u003c= n; i++) {  // 使用动态规划，计算n步爬楼梯的不同方法数\n    c = a + b;\n    a = b;\n    b = c;\n  }\n  return c;\n}\n\n// 示例\nconsole.log(climbStairs(2));  // 2，因为有两种不同的爬楼梯方法：一次爬1级或者一次爬2级\nconsole.log(climbStairs(3));  // 3，因为有三种不同的爬楼梯方法：一次爬1级、一次爬2级、或者一次爬1级再一次爬2级\nconsole.log(climbStairs(4));  // 5，因为有五种不同的爬楼梯方法：一次爬1级、一次爬2级、一次爬1级再一次爬2级、一次爬2级再一次爬2级、或者一次爬1级再一次爬1级再一次爬2级\n```\n\n## 斐波那契数列\n\n类似于爬楼梯问题，用动态规划。\n\n``` javascript\nfunction fibonacci(n) {\n  if (n === 0 || n === 1) {  // 当n等于0或1时，返回n\n    return n;\n  }\n  let a = 0, b = 1, c;\n  for (let i = 2; i \u003c= n; i++) {  // 使用动态规划，计算斐波那契数列的第n项\n    c = a + b;\n    a = b;\n    b = c;\n  }\n  return c;\n}\n\n// 示例\nconsole.log(fibonacci(0));  // 0\nconsole.log(fibonacci(1));  // 1\nconsole.log(fibonacci(2));  // 1\nconsole.log(fibonacci(3));  // 2\nconsole.log(fibonacci(4));  // 3\n```\n\n## 遍历二叉树\n\n定义二叉树节点：\n\n``` javascript\n// 定义二叉树节点\nclass TreeNode {\n  constructor(val) {\n    this.val = val;\n    this.left = null;\n    this.right = null;\n  }\n}\n```\n\n前序遍历：\n\n``` javascript\n// 前序遍历\nfunction preorderTraversal(root) {\n  const res = [];  // 用于存储遍历结果\n  function preorder(root) {\n    if (!root) {\n      return;\n    }\n    res.push(root.val);\n    preorder(root.left);\n    preorder(root.right);\n  }\n  preorder(root);\n  return res;\n}\n// 示例\nconst root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(3);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(5);\n\nconsole.log(preorderTraversal(root));  // [1, 2, 4, 5, 3]\n```\n\n中序遍历：\n\n``` javascript\n// 中序遍历\nfunction inorderTraversal(root) {\n  const res = [];  // 用于存储遍历结果\n  function inorder(root) {\n    if (!root) {\n      return;\n    }\n    inorder(root.left);\n    res.push(root.val);\n    inorder(root.right);\n  }\n  inorder(root);\n  return res;\n}\n\n// 示例\nconst root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(3);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(5);\n\nconsole.log(inorderTraversal(root));   // [4, 2, 5, 1, 3]\n```\n\n后序遍历：\n\n``` javascript\n// 后序遍历\nfunction postorderTraversal(root) {\n  const res = [];  // 用于存储遍历结果\n  function postorder(root) {\n    if (!root) {\n      return;\n    }\n    postorder(root.left);\n    postorder(root.right);\n    res.push(root.val);\n  }\n  postorder(root);\n  return res;\n}\n\n// 示例\nconst root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(3);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(5);\n\nconsole.log(postorderTraversal(root)); // [4, 5, 2, 3, 1]\n```","slug":"interview-algorithm","html":"\u003ch2\u003e算法面试心得\u003c/h2\u003e\n\u003cp\u003e关于算法面试，实在是没什么太好的捷径，如果想面试外企或者对算法要求比较高的企业，老老实实刷Leetcode就得了。\u003c/p\u003e\n\u003cp\u003e对于怎么刷Leetcode，在这里给一些建议：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e分类刷题，比如动态规划、双指针、二叉树这些。刷多了你就会发现，同一个类型的题，解题套路和编码步骤都是类似的。\u003c/li\u003e\n\u003cli\u003e尽量少刷难度为Hard的题，对于前端来说，面试中碰到Hard的算法题概率还是很低的，刷难度高的题一是收益不大，二是可能会打击你的信心。\u003c/li\u003e\n\u003cli\u003e对于非计算机专业或者算法基础薄弱的同学，有空闲时间最好找一些课程系统地学习数据结构和算法，不然直接刷题会面临很多挑战。\u003c/li\u003e\n\u003cli\u003e保持耐心别着急，贵在坚持，一周哪怕就刷两道题，只要消化了就好。\u003c/li\u003e\n\u003cli\u003e实际上绝大多数企业包括大厂，其实对前端的算法能力要求并不会太高，一本《剑指Offer》足矣。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e快排\u003c/h2\u003e\n\u003cp\u003e最常见的基础算法，很多面试一上来就让写个快排，所以必须掌握。\u003c/p\u003e\n\u003cp\u003e思路：把一个数组分成两个子数组来递归地解决问题，选择一个基准值，然后将小于等于基准值的元素移到数组左侧，将大于基准值的元素移到数组右侧，再对左右两个子数组递归进行排序，最终得到一个有序的数组。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction quickSort(arr) {\n  if (arr.length \u0026#x3C;= 1) {  // 如果数组长度小于等于1，直接返回\n    return arr;\n  }\n  const pivotIndex = Math.floor(arr.length / 2);  // 选择基准值\n  const pivot = arr.splice(pivotIndex, 1)[0];  // 将基准值从数组中删除，并保存基准值\n  const left = [], right = [];\n  for (let i = 0; i \u0026#x3C; arr.length; i++) {\n    if (arr[i] \u0026#x3C; pivot) {  // 将小于基准值的元素放入左子数组\n      left.push(arr[i]);\n    } else {  // 将大于等于基准值的元素放入右子数组\n      right.push(arr[i]);\n    }\n  }\n  return quickSort(left).concat([pivot], quickSort(right));  // 对左右子数组递归进行排序，最终合并为一个有序数组\n}\n\n// 示例\nconst arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];\nconsole.log(quickSort(arr));  // [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e二分搜索\u003c/h2\u003e\n\u003cp\u003e利用数组有序这一特点，将查找区间不断缩小一半，从而快速地定位目标元素。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction binarySearch(arr, target) {\n  let left = 0, right = arr.length - 1;\n  while (left \u0026#x3C;= right) {  // 当查找区间非空时\n    const mid = Math.floor((left + right) / 2);  // 计算中间位置\n    if (arr[mid] === target) {  // 如果中间位置的元素就是目标元素，直接返回\n      return mid;\n    } else if (arr[mid] \u0026#x3C; target) {  // 如果中间位置的元素小于目标元素，将查找区间缩小为右半部分\n      left = mid + 1;\n    } else {  // 如果中间位置的元素大于目标元素，将查找区间缩小为左半部分\n      right = mid - 1;\n    }\n  }\n  return -1;  // 如果没有找到目标元素，返回-1\n}\n\n// 示例\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nconsole.log(binarySearch(arr, 5));  // 4\nconsole.log(binarySearch(arr, 10));  // -1\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eLRU缓存算法\u003c/h2\u003e\n\u003cp\u003e有缓存的地方就有LRU，比如说Vue的keep-alive就是用的LRU缓存算法实现的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eclass LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;  // 缓存容量\n    this.map = new Map();  // 使用Map来存储缓存数据，实现O(1)的查找和删除\n  }\n\n  get(key) {\n    const value = this.map.get(key);  // 查找缓存数据\n    if (value === undefined) {  // 如果数据不存在，返回-1\n      return -1;\n    } else {  // 如果数据存在，将其从Map中删除并重新插入到Map的最后面\n      this.map.delete(key);\n      this.map.set(key, value);\n      return value;\n    }\n  }\n\n  put(key, value) {\n    if (this.map.has(key)) {  // 如果缓存数据已存在，将其从Map中删除\n      this.map.delete(key);\n    }\n    this.map.set(key, value);  // 插入新的缓存数据到Map的最后面\n    if (this.map.size \u003e this.capacity) {  // 如果缓存容量已满，删除最近最少使用的缓存数据\n      const oldestKey = this.map.keys().next().value;  // 获取Map中第一个键，即最近最少使用的缓存数据的键\n      this.map.delete(oldestKey);\n    }\n  }\n}\n\n// 示例\nconst cache = new LRUCache(2);  // 初始化容量为2的LRU缓存\ncache.put(1, 1);\ncache.put(2, 2);\nconsole.log(cache.get(1));  // 1，因为缓存中存在键为1的数据\ncache.put(3, 3);  // 缓存容量已满，删除最近最少使用的缓存数据（键为2的数据）\nconsole.log(cache.get(2));  // -1，因为缓存中不存在键为2的数据\ncache.put(4, 4);  // 缓存容量已满，删除最近最少使用的缓存数据（键为1的数据）\nconsole.log(cache.get(1));  // -1，因为缓存中不存在键为1的数据\nconsole.log(cache.get(3));  // 3，因为缓存中存在键为3的数据\nconsole.log(cache.get(4));  // 4，因为缓存中存在键为4的数据\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e爬楼梯问题\u003c/h2\u003e\n\u003cp\u003e最基础的动态规划题，必须掌握。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction climbStairs(n) {\n  if (n \u0026#x3C;= 2) {  // 当n小于等于2时，有n种不同的爬楼梯方法\n    return n;\n  }\n  let a = 1, b = 2, c;\n  for (let i = 3; i \u0026#x3C;= n; i++) {  // 使用动态规划，计算n步爬楼梯的不同方法数\n    c = a + b;\n    a = b;\n    b = c;\n  }\n  return c;\n}\n\n// 示例\nconsole.log(climbStairs(2));  // 2，因为有两种不同的爬楼梯方法：一次爬1级或者一次爬2级\nconsole.log(climbStairs(3));  // 3，因为有三种不同的爬楼梯方法：一次爬1级、一次爬2级、或者一次爬1级再一次爬2级\nconsole.log(climbStairs(4));  // 5，因为有五种不同的爬楼梯方法：一次爬1级、一次爬2级、一次爬1级再一次爬2级、一次爬2级再一次爬2级、或者一次爬1级再一次爬1级再一次爬2级\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e斐波那契数列\u003c/h2\u003e\n\u003cp\u003e类似于爬楼梯问题，用动态规划。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction fibonacci(n) {\n  if (n === 0 || n === 1) {  // 当n等于0或1时，返回n\n    return n;\n  }\n  let a = 0, b = 1, c;\n  for (let i = 2; i \u0026#x3C;= n; i++) {  // 使用动态规划，计算斐波那契数列的第n项\n    c = a + b;\n    a = b;\n    b = c;\n  }\n  return c;\n}\n\n// 示例\nconsole.log(fibonacci(0));  // 0\nconsole.log(fibonacci(1));  // 1\nconsole.log(fibonacci(2));  // 1\nconsole.log(fibonacci(3));  // 2\nconsole.log(fibonacci(4));  // 3\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e遍历二叉树\u003c/h2\u003e\n\u003cp\u003e定义二叉树节点：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// 定义二叉树节点\nclass TreeNode {\n  constructor(val) {\n    this.val = val;\n    this.left = null;\n    this.right = null;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e前序遍历：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// 前序遍历\nfunction preorderTraversal(root) {\n  const res = [];  // 用于存储遍历结果\n  function preorder(root) {\n    if (!root) {\n      return;\n    }\n    res.push(root.val);\n    preorder(root.left);\n    preorder(root.right);\n  }\n  preorder(root);\n  return res;\n}\n// 示例\nconst root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(3);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(5);\n\nconsole.log(preorderTraversal(root));  // [1, 2, 4, 5, 3]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e中序遍历：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// 中序遍历\nfunction inorderTraversal(root) {\n  const res = [];  // 用于存储遍历结果\n  function inorder(root) {\n    if (!root) {\n      return;\n    }\n    inorder(root.left);\n    res.push(root.val);\n    inorder(root.right);\n  }\n  inorder(root);\n  return res;\n}\n\n// 示例\nconst root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(3);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(5);\n\nconsole.log(inorderTraversal(root));   // [4, 2, 5, 1, 3]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e后序遍历：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// 后序遍历\nfunction postorderTraversal(root) {\n  const res = [];  // 用于存储遍历结果\n  function postorder(root) {\n    if (!root) {\n      return;\n    }\n    postorder(root.left);\n    postorder(root.right);\n    res.push(root.val);\n  }\n  postorder(root);\n  return res;\n}\n\n// 示例\nconst root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(3);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(5);\n\nconsole.log(postorderTraversal(root)); // [4, 5, 2, 3, 1]\n\u003c/code\u003e\u003c/pre\u003e\n"}},"__N_SSG":true},"page":"/[slug]","query":{"slug":"interview-algorithm"},"buildId":"d2zJ11P1rS-26pC0W69Ok","assetPrefix":"/interview","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>