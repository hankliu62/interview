<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>卡鲁秋 - 前端面试题汇总</title><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="4"/><meta charSet="utf-8"/><meta name="robots" content="follow, index"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><link rel="preload" href="/interview/_next/static/css/5518ada2dd4eaf66.css" as="style" crossorigin=""/><link rel="stylesheet" href="/interview/_next/static/css/5518ada2dd4eaf66.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/interview/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/interview/_next/static/chunks/webpack-b0a39061ef5434f8.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/framework-5429a50ba5373c56.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/main-846b70f57d3f15ee.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/pages/_app-9a697299b91baa3f.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/pages/%5Bslug%5D-e58918b5e268a43a.js" defer="" crossorigin=""></script><script src="/interview/_next/static/d2zJ11P1rS-26pC0W69Ok/_buildManifest.js" defer="" crossorigin=""></script><script src="/interview/_next/static/d2zJ11P1rS-26pC0W69Ok/_ssgManifest.js" defer="" crossorigin=""></script></head><body class="bg-white text-gray-700 antialiased"><div id="__next"><div class="flex h-full min-h-[100vh] w-full flex-col" style="flex-direction:column;min-height:100vh"><main class="flex flex-1 grow-[1] flex-col" style="flex:1"><div class="bg-white p-6"><div class="flex flex-col space-y-6"><article><header><h1 class="text-4xl font-bold"></h1></header><div></div></article></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"post":{"content":"## TS有什么优缺点？为什么要用TS？\n\n### TS 的优点：\n\n- 可以减少低级的语法错误。\n- 规范团队代码，对大型项目来说规范很重要。\n- 智能提示，定义类型能让编辑器更好的自动提示，提升编码效率。\n\n### TS 的缺点：\n\n- 学习成本高。\n- 开发成本高，又要做业务又要编写类型文件，有时候还得解决奇奇怪怪的报错。\n\n### 适用场景：\n\n- 大型项目和团队开发。\n- 库和框架开发。\n- 对于一些重要的逻辑或者代码，可以使用TS来增强其可靠性。\n\n## 什么是泛型,有什么作用？\n\nTS泛型简单来说就是类型参数，在定义某些函数、接口和类时，不写死类型，而是改用类型参数的形式，让类型更加灵活。\n\n举个简单的例子，我们定义一个数据响应体的接口：\n\n``` typescript\ninterface IResponseData\u003cT\u003e{\n    code: number;\n    message?: string;\n    data: T;\n}\n```\n\n其中data的类型并没有写死，而是可以在我们使用的时候传入：\n\n``` typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// 使用时传入User类型\nconst response: IResponseData\u003cUser\u003e = {\n  code: 200,\n  message: \"Success\",\n  data: {\n    id: 1,\n    name: \"xiaoming\",\n    email: \"xxx@qq.com\"\n  }\n};\n```\n\n## 类型别名type和接口interface有什么区别？\n\n1. 类型别名不能被继承或者实现，接口可以被继承或者实现。\n2. 类型别名可以定义任何类型，包括联合类型、交叉类型、字面量类型、原始类型等。接口只能定义对象类型，包括属性、方法、索引等。\n3. 类型别名通常用于为复杂类型创建别名，以方便在代码中使用。接口通常用于定义某个实体的结构，以及实现该结构的对象或类。\n\n总结一下，如果你需要定义一个对象类型，或者需要使用继承和实现的特性，那么应该使用接口；如果你需要定义任意类型的别名，或者需要定义联合类型和交叉类型等复杂类型，那么应该使用类型别名。\n\n## 什么是装饰器？\n\n装饰器的作用，简单来说就是代码复用，和Java里的注解以及Rust里的属性宏类似。\n\n把通用的代码封装成装饰器，然后在使用的时候就可以将`@xxx`添加在方法或者类上，方法和类就得到了加强，特别简洁优雅。\n\n例如mobx里的`@observable`以及NestJS里的`@Controller`。\n\n举个简单的自定义装饰器例子，我们来实现一个自动打印函数参数以及返回值的装饰器。\n\n首先来定义装饰器：\n\n``` Typescript\n// target表示装饰的目标对象\n// propertyKey表示装饰的属性或方法名\n// descriptor表示属性或方法的描述符\nfunction log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const originalMethod = descriptor.value;\n\n  descriptor.value = function (...args: any[]) {\n    console.log(`调用 ${propertyKey}，参数为: ${JSON.stringify(args)}`);\n    const result = originalMethod.apply(this, args);\n    console.log(`方法 ${propertyKey} 返回值为: ${JSON.stringify(result)}`);\n    return result;\n  };\n\n  return descriptor;\n}\n```\n\n然后使用一下这个装饰器：\n\n``` typescript\nclass Test {\n  @log\n  add(a: number, b: number) {\n    return a + b;\n  }\n}\n\nconst test = new Test();\nconsole.log(test.add(2, 3)); // 会打印出参数2,3和返回值5\n```\n\n## 什么是类型体操，有哪些应用？\n\nTS类型体操指的是用各种技巧和骚操作来创建复杂类型。\n\n类型体操一般在业务项目里出现的少，在三方库里出现的多，比如Vue3源码里面就有很多复杂的类型体操运算。\n\n关于类型体操，褒贬不一，有人认为是秀操作，实际作用不大，也有人认为很高级。\n\n我个人是不太倾向在前端项目里执着于玩类型体操的，但是一些常见的TS技巧是需要学习的，比如类型别名、交叉类型和联合类型、条件类型、工具类型、泛型，在处理复杂类型运算的时候，就很有用。\n\n## any用的多吗，有什么弊端？\n\n使用any类型的主要目的是在不清楚变量类型的情况下避免编译错误，但是，频繁地使用any类型那就等于白白浪费了TS的类型检查能力。\n\n正确的做法是尽可能避免使用any类型，尽可能地使用明确的类型，这样可以提高代码的可读性和可维护性，并且可以减少潜在的运行时错误。\n\n但是有时候时间紧任务重又不得不用，所以一句话总结就是，尽量不用，不到万不得已不轻易用any。\n\n## 你知道哪些工具类型，怎么用？\n\n工具类型主要用于处理和转换已有类型，它们不是实际的类型，而是用来处理类型的工具。简单来说，工具类型可以认为是TS类型的工具函数，把原有类型当参数来处理。\n\n举一个简单的Partial工具类型应用的例子：\n\n``` typescript\n// 已有类型User\ninterface User {\n  name: string;\n  age: number;\n}\n\n// 新类型PartialUser，使用Partial将属性都变成可选\ntype PartialUser = Partial\u003cUser\u003e; // { name?: string; age?: number; }\n```\n\n常用工具类型有：\n\n- **Partial\u003cT\u003e**：将类型 T 的所有属性变为可选属性。\n- **Required\u003cT\u003e**：将类型 T 的所有属性变为必选属性。\n- **Readonly\u003cT\u003e**：将类型 T 的所有属性变为只读属性。\n- **Record\u003cK, T\u003e**：创建一个类型，其中属性名为类型 K 中的值，属性值为类型 T 中的值。\n- **Pick\u003cT, K\u003e**：从类型 T 中选择属性名为类型 K 中的属性，创建一个新类型。\n- **Omit\u003cT, K\u003e**：从类型 T 中排除属性名为类型 K 中的属性，创建一个新类型。\n- **Exclude\u003cT, U\u003e**：从类型 T 中排除类型 U 中的所有属性。\n- **Extract\u003cT, U\u003e**：从类型 T 中提取类型 U 中存在的所有属性。\n- **NonNullable\u003cT\u003e**：从类型 T 中移除 null 和 undefined。\n- **ReturnType\u003cT\u003e**：获取函数类型 T 的返回值类型。\n\n## TS里怎么处理第三方库类型，怎么给第三方库编写类型文件？\n\nTS社区维护了一个名为DefinitelyTyped的项目，提供了大量的第三方库的类型定义文件，大多数三方库类型文件都可以直接在这里面下载。\n\n但是如果第三方库没有提供类型定义文件时，我们可以通过手动编写类型文件的方式，为第三方库添加类型支持。\n\n给三方库编写类型的文件步骤如下：\n\n1. 创建d.ts文件：在项目中创建一个新的d.ts文件，文件名可以与库名相同，例如`lodash.d.ts`。\n\n2. 定义模块：使用`declare module`语句定义模块名，模块名应与库的导出模块名一致。例如，对于lodash库，可以这样定义模块：\n\n``` Typescript\ndeclare module 'lodash' {\n  // 在此处添加类型定义\n}\n```\n\n3. 添加类型定义：在模块内部添加对应的类型定义，例如函数、变量、类等。根据需要，可以使用 interface、type、class 等关键字定义不同类型的接口。\n\n4. 导出类型：使用 export 关键字导出需要公开的类型。例如，对于以下的 utils 函数，可以这样定义：\n\n``` typescript\ndeclare module 'lodash' {\n  function utils(...args: any[]): any;\n  export { utils };\n}\n```\n\n5. 使用类型文件：在需要使用第三方库的地方，通过import语句引入类型定义即可：\n\n``` typescript\nimport { utils } from 'lodash';\n```\n\n## React项目怎么使用TS？Vue项目怎么使用TS？\n\n### React：\nReact脚手架自带TS模板，新建项目的时候，带上参数即可。\n\nReact项目里需要考虑类型的地方主要有：\n\n- 定义props和state的类型。\n- 事件处理函数中事件对象的类型，尽量不要用any。\n- 对三方库的封装要考虑类型。\n- 对于Hooks的参数和返回值的约束类型。\n- 数据接口需要定义类型。\n\n### Vue：\n\n- Vue2项目可以通过添加 class-component 和 vue-property-decorator 库来使用TS。\n\n- Vue3对TS支持更好，可以通过vue-cli或者vite来直接启动TS模板的脚手架。","slug":"interview-typescript","html":"\u003ch2\u003eTS有什么优缺点？为什么要用TS？\u003c/h2\u003e\n\u003ch3\u003eTS 的优点：\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e可以减少低级的语法错误。\u003c/li\u003e\n\u003cli\u003e规范团队代码，对大型项目来说规范很重要。\u003c/li\u003e\n\u003cli\u003e智能提示，定义类型能让编辑器更好的自动提示，提升编码效率。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eTS 的缺点：\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e学习成本高。\u003c/li\u003e\n\u003cli\u003e开发成本高，又要做业务又要编写类型文件，有时候还得解决奇奇怪怪的报错。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e适用场景：\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e大型项目和团队开发。\u003c/li\u003e\n\u003cli\u003e库和框架开发。\u003c/li\u003e\n\u003cli\u003e对于一些重要的逻辑或者代码，可以使用TS来增强其可靠性。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e什么是泛型,有什么作用？\u003c/h2\u003e\n\u003cp\u003eTS泛型简单来说就是类型参数，在定义某些函数、接口和类时，不写死类型，而是改用类型参数的形式，让类型更加灵活。\u003c/p\u003e\n\u003cp\u003e举个简单的例子，我们定义一个数据响应体的接口：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003einterface IResponseData\u0026#x3C;T\u003e{\n    code: number;\n    message?: string;\n    data: T;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中data的类型并没有写死，而是可以在我们使用的时候传入：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003einterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// 使用时传入User类型\nconst response: IResponseData\u0026#x3C;User\u003e = {\n  code: 200,\n  message: \"Success\",\n  data: {\n    id: 1,\n    name: \"xiaoming\",\n    email: \"xxx@qq.com\"\n  }\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e类型别名type和接口interface有什么区别？\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e类型别名不能被继承或者实现，接口可以被继承或者实现。\u003c/li\u003e\n\u003cli\u003e类型别名可以定义任何类型，包括联合类型、交叉类型、字面量类型、原始类型等。接口只能定义对象类型，包括属性、方法、索引等。\u003c/li\u003e\n\u003cli\u003e类型别名通常用于为复杂类型创建别名，以方便在代码中使用。接口通常用于定义某个实体的结构，以及实现该结构的对象或类。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e总结一下，如果你需要定义一个对象类型，或者需要使用继承和实现的特性，那么应该使用接口；如果你需要定义任意类型的别名，或者需要定义联合类型和交叉类型等复杂类型，那么应该使用类型别名。\u003c/p\u003e\n\u003ch2\u003e什么是装饰器？\u003c/h2\u003e\n\u003cp\u003e装饰器的作用，简单来说就是代码复用，和Java里的注解以及Rust里的属性宏类似。\u003c/p\u003e\n\u003cp\u003e把通用的代码封装成装饰器，然后在使用的时候就可以将\u003ccode\u003e@xxx\u003c/code\u003e添加在方法或者类上，方法和类就得到了加强，特别简洁优雅。\u003c/p\u003e\n\u003cp\u003e例如mobx里的\u003ccode\u003e@observable\u003c/code\u003e以及NestJS里的\u003ccode\u003e@Controller\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e举个简单的自定义装饰器例子，我们来实现一个自动打印函数参数以及返回值的装饰器。\u003c/p\u003e\n\u003cp\u003e首先来定义装饰器：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003e// target表示装饰的目标对象\n// propertyKey表示装饰的属性或方法名\n// descriptor表示属性或方法的描述符\nfunction log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const originalMethod = descriptor.value;\n\n  descriptor.value = function (...args: any[]) {\n    console.log(`调用 ${propertyKey}，参数为: ${JSON.stringify(args)}`);\n    const result = originalMethod.apply(this, args);\n    console.log(`方法 ${propertyKey} 返回值为: ${JSON.stringify(result)}`);\n    return result;\n  };\n\n  return descriptor;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e然后使用一下这个装饰器：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003eclass Test {\n  @log\n  add(a: number, b: number) {\n    return a + b;\n  }\n}\n\nconst test = new Test();\nconsole.log(test.add(2, 3)); // 会打印出参数2,3和返回值5\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e什么是类型体操，有哪些应用？\u003c/h2\u003e\n\u003cp\u003eTS类型体操指的是用各种技巧和骚操作来创建复杂类型。\u003c/p\u003e\n\u003cp\u003e类型体操一般在业务项目里出现的少，在三方库里出现的多，比如Vue3源码里面就有很多复杂的类型体操运算。\u003c/p\u003e\n\u003cp\u003e关于类型体操，褒贬不一，有人认为是秀操作，实际作用不大，也有人认为很高级。\u003c/p\u003e\n\u003cp\u003e我个人是不太倾向在前端项目里执着于玩类型体操的，但是一些常见的TS技巧是需要学习的，比如类型别名、交叉类型和联合类型、条件类型、工具类型、泛型，在处理复杂类型运算的时候，就很有用。\u003c/p\u003e\n\u003ch2\u003eany用的多吗，有什么弊端？\u003c/h2\u003e\n\u003cp\u003e使用any类型的主要目的是在不清楚变量类型的情况下避免编译错误，但是，频繁地使用any类型那就等于白白浪费了TS的类型检查能力。\u003c/p\u003e\n\u003cp\u003e正确的做法是尽可能避免使用any类型，尽可能地使用明确的类型，这样可以提高代码的可读性和可维护性，并且可以减少潜在的运行时错误。\u003c/p\u003e\n\u003cp\u003e但是有时候时间紧任务重又不得不用，所以一句话总结就是，尽量不用，不到万不得已不轻易用any。\u003c/p\u003e\n\u003ch2\u003e你知道哪些工具类型，怎么用？\u003c/h2\u003e\n\u003cp\u003e工具类型主要用于处理和转换已有类型，它们不是实际的类型，而是用来处理类型的工具。简单来说，工具类型可以认为是TS类型的工具函数，把原有类型当参数来处理。\u003c/p\u003e\n\u003cp\u003e举一个简单的Partial工具类型应用的例子：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// 已有类型User\ninterface User {\n  name: string;\n  age: number;\n}\n\n// 新类型PartialUser，使用Partial将属性都变成可选\ntype PartialUser = Partial\u0026#x3C;User\u003e; // { name?: string; age?: number; }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e常用工具类型有：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePartial\u003c/strong\u003e：将类型 T 的所有属性变为可选属性。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRequired\u003c/strong\u003e：将类型 T 的所有属性变为必选属性。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eReadonly\u003c/strong\u003e：将类型 T 的所有属性变为只读属性。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRecord\u0026#x3C;K, T\u003e\u003c/strong\u003e：创建一个类型，其中属性名为类型 K 中的值，属性值为类型 T 中的值。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePick\u0026#x3C;T, K\u003e\u003c/strong\u003e：从类型 T 中选择属性名为类型 K 中的属性，创建一个新类型。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eOmit\u0026#x3C;T, K\u003e\u003c/strong\u003e：从类型 T 中排除属性名为类型 K 中的属性，创建一个新类型。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eExclude\u0026#x3C;T, U\u003e\u003c/strong\u003e：从类型 T 中排除类型 U 中的所有属性。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eExtract\u0026#x3C;T, U\u003e\u003c/strong\u003e：从类型 T 中提取类型 U 中存在的所有属性。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNonNullable\u003c/strong\u003e：从类型 T 中移除 null 和 undefined。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eReturnType\u003c/strong\u003e：获取函数类型 T 的返回值类型。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eTS里怎么处理第三方库类型，怎么给第三方库编写类型文件？\u003c/h2\u003e\n\u003cp\u003eTS社区维护了一个名为DefinitelyTyped的项目，提供了大量的第三方库的类型定义文件，大多数三方库类型文件都可以直接在这里面下载。\u003c/p\u003e\n\u003cp\u003e但是如果第三方库没有提供类型定义文件时，我们可以通过手动编写类型文件的方式，为第三方库添加类型支持。\u003c/p\u003e\n\u003cp\u003e给三方库编写类型的文件步骤如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e创建d.ts文件：在项目中创建一个新的d.ts文件，文件名可以与库名相同，例如\u003ccode\u003elodash.d.ts\u003c/code\u003e。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e定义模块：使用\u003ccode\u003edeclare module\u003c/code\u003e语句定义模块名，模块名应与库的导出模块名一致。例如，对于lodash库，可以这样定义模块：\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003edeclare module 'lodash' {\n  // 在此处添加类型定义\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e\n\u003cp\u003e添加类型定义：在模块内部添加对应的类型定义，例如函数、变量、类等。根据需要，可以使用 interface、type、class 等关键字定义不同类型的接口。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e导出类型：使用 export 关键字导出需要公开的类型。例如，对于以下的 utils 函数，可以这样定义：\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003edeclare module 'lodash' {\n  function utils(...args: any[]): any;\n  export { utils };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e使用类型文件：在需要使用第三方库的地方，通过import语句引入类型定义即可：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003eimport { utils } from 'lodash';\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eReact项目怎么使用TS？Vue项目怎么使用TS？\u003c/h2\u003e\n\u003ch3\u003eReact：\u003c/h3\u003e\n\u003cp\u003eReact脚手架自带TS模板，新建项目的时候，带上参数即可。\u003c/p\u003e\n\u003cp\u003eReact项目里需要考虑类型的地方主要有：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e定义props和state的类型。\u003c/li\u003e\n\u003cli\u003e事件处理函数中事件对象的类型，尽量不要用any。\u003c/li\u003e\n\u003cli\u003e对三方库的封装要考虑类型。\u003c/li\u003e\n\u003cli\u003e对于Hooks的参数和返回值的约束类型。\u003c/li\u003e\n\u003cli\u003e数据接口需要定义类型。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eVue：\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eVue2项目可以通过添加 class-component 和 vue-property-decorator 库来使用TS。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eVue3对TS支持更好，可以通过vue-cli或者vite来直接启动TS模板的脚手架。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/[slug]","query":{"slug":"interview-typescript"},"buildId":"d2zJ11P1rS-26pC0W69Ok","assetPrefix":"/interview","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>