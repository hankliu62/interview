<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>卡鲁秋 - 前端面试题汇总</title><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="4"/><meta charSet="utf-8"/><meta name="robots" content="follow, index"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><link rel="preload" href="/interview/_next/static/css/5518ada2dd4eaf66.css" as="style" crossorigin=""/><link rel="stylesheet" href="/interview/_next/static/css/5518ada2dd4eaf66.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/interview/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/interview/_next/static/chunks/webpack-b0a39061ef5434f8.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/framework-5429a50ba5373c56.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/main-846b70f57d3f15ee.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/pages/_app-9a697299b91baa3f.js" defer="" crossorigin=""></script><script src="/interview/_next/static/chunks/pages/%5Bslug%5D-e58918b5e268a43a.js" defer="" crossorigin=""></script><script src="/interview/_next/static/u_x12eLn2XCxdSz5n9-ra/_buildManifest.js" defer="" crossorigin=""></script><script src="/interview/_next/static/u_x12eLn2XCxdSz5n9-ra/_ssgManifest.js" defer="" crossorigin=""></script></head><body class="bg-white text-gray-700 antialiased"><div id="__next"><div class="flex h-full min-h-[100vh] w-full flex-col" style="flex-direction:column;min-height:100vh"><main class="flex flex-1 grow-[1] flex-col" style="flex:1"><div class="bg-white p-6"><div class="flex flex-col space-y-6"><article><header><h1 class="text-4xl font-bold"></h1></header><div></div></article></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"post":{"content":"## 什么是前端工程化？\n\n- 模块化：AMD、CMD、commonjs、ESM。\n- 自动化：自动化测试、自动化构建、自动化部署。\n- 规范化：Vue编码规范、React编码规范、Git提交规范、文档规范。\n- 各种工具：Webpack、Rollup、Vite、Babel、PostCSS。\n\n## 包管理器用的哪个？\nnpm、cnpm、yarn、pnpm，或者有些大公司会自建包管理器。\n\nnpm和yarn的原理类似，但是yarn相对来说速度更快。\n\npnpm与npm、yarn不同，pnpm不会将每个包都复制到项目的node_modules文件夹中，而是将所有包放在一个公共存储库中，并且在需要使用包时将其链接到项目中。这种方法可以减少磁盘使用量，并提高安装和更新速度。\n\n推荐使用yarn和pnpm，速度更快，更稳定。\n\n## 有没有写过自动化测试，怎么做前端自动化测试？\n\n### 测试的优缺点\n\n- 优点：提高测试效率、确保代码质量，重构舒服\n- 缺点：学习成本高，需要额外的时间来思考和编写测试代码\n\n### 测试的分类\n\n- 单元测试：针对代码的最小单元进行测试，例如测试函数或模块等。\n- 集成测试：将多个模块组合在一起进行测试，确保它们在一起能够正确地工作。\n- 端到端测试：模拟用户在应用程序中执行操作的场景，例如点击按钮、输入文本等。\n\n### 测试常用框架\n\n- **Jest**：基础测试框架，一般测试就是选个基础框架，然后再选一些测试工具。\n\n- **vue-test-utils**：vue-test-utils 是一个 Vue.js 官方的单元测试实用工具库，提供了许多 API 来方便地测试 Vue 组件。在单元测试中，可以通过模拟组件的 props、methods、data 等属性和方法，以及通过创建 wrapper 对象来访问组件实例的生命周期钩子函数，来进行组件的测试。此外，还可以使用 snapshot 测试来测试组件的渲染输出是否符合预期。\n\n- **Cypress**：Cypress是一个用于 Web 应用程序的端到端测试工具，它可以模拟用户操作和行为，以及监控页面状态和 DOM 变化等。\n\n- **Enzyme**：Enzyme 是一个 React 组件测试实用工具库，提供了许多 API 来方便地测试 React 组件。在单元测试中，可以通过模拟组件的 props、state、函数和生命周期钩子等属性和方法，以及通过创建 wrapper 对象来访问组件实例的 DOM 节点和事件，来进行组件的测试。\n\n### 测试检验结果\n\n通过测试覆盖率当成测试的检验结果，测试覆盖率是衡量测试用例覆盖源代码的程度的指标，包括行覆盖率、分支覆盖率、函数覆盖率和语句覆盖率。测试覆盖率可以评估测试用例的质量和完整性，帮助开发人员确定需要更多测试的部分，并作为一种度量软件质量的指标。覆盖率越高，说明被测试的代码被验证的越充分，软件更加稳定和可靠。\n\n### 总结\n\n一般在项目里如果只是做UI开发，大多数情况下不用写自动化测试，但是一些封装的工具，组件库，插件之类的，可以写测试提高代码健壮性。\n\n## 什么是持续集成？\n持续集成，简称CI。CI有以下好处：\n\n- CI作为敏捷开发重要的一步，其目的在于让产品快速迭代的同时，尽可能保持高质量.\n- CI可以增加项目可见性，降低项目失败风险的开发实践。其每一次代码更新，都要通过自动化测试来检测代码和功能的正确性，只有通过自动测试的代码才能进行后续的交付和部署.\n- CI 是团队成员间（产研测）更好地协调工作，更好的适应敏捷迭代开发，自动完成减少人工干预，保证每个时间点上团队成员提交的代码都能成功集成的，可以很好的用于对各种WEB、APP项目的打包.\n\n一般是借助Jenkins、Docker、Travis、GitLab等工具来实现，大多数时候是由后端或者运维来做这个事的，但是在公司没有专业运维的情况下，前端负责人也可以考虑给项目上持续集成。\n\n## 用过Babel吗？讲一下你对Babel的了解？\n\nBabel是一个JS编译器，用通俗的话解释就是它主要用于将高版本的JavaScript代码转为向后兼容的JS代码，从而能让我们的代码运行在更低版本的浏览器或者其他的环境中。\n\nBabel的核心就是plugin、preset。\n\n1. **plugin**：Babel功能的实现就是靠着各种plugin，Babel插件包括语法插件和转换插件。\n\n2. **preset**：预设，一组plugin的组合，共同完成一个大功能。\n\nBabel执行原理:\n\n1. 解析: 将代码字符串转换成 AST抽象语法树\n2. 转换: 访问AST的节点进行变换操作生成新的 AST\n3. 生成: 以新的AST为基础生成代码\n\n## ESLint有什么用？你有用它来规范过团队代码吗？\nESLint是JS代码检查工具，可以用来规范前端代码风格和发现潜在的代码错误。\n\n很多初学者不愿意用这样的代码检查工具，因为总会报错。但是对于有经验的开发者或者说团队管理者来说，它可以规范团队小伙伴的编码风格。\n\nESLint常用的配置有：\n\n- rules：指定规则，包括警告和错误规则，可以覆盖继承规则集中的规则或自定义规则。\n- plugins：指定插件，可以使用已有的插件如eslint-plugin-react或自定义插件。\n\n## 讲一下你了解哪些前端模块化规范？\n\n1. ES6 模块化：ES6 模块化是一种 JavaScript 模块化规范，是 ES6 中新增的语言特性。在 ES6 中，每个模块都是一个独立的文件，并通过 export 导出模块，通过 import 导入模块。例如：\n\n``` javascript\n// 导出模块\nexport var foo = 'bar';\nexport function add(x, y) {\n  return x + y;\n}\n\n// 导入模块\nimport {foo, add} from 'module';\nconsole.log(foo); // 'bar'\nconsole.log(add(1, 2)); // 3\n```\n\n2. CommonJS：Node.js的模块化规范。在CommonJS中，每个模块都是一个单独的文件，并通过module.exports导出模块，通过require()导入模块。例如：\n\n``` javascript\n// 导出模块\nmodule.exports = {\n  foo: 'bar',\n  add: function(x, y) {\n    return x + y;\n  }\n};\n\n// 导入模块\nvar module = require('module');\nconsole.log(module.foo); // 'bar'\nconsole.log(module.add(1, 2)); // 3\n```\n\n3. AMD和CMD：以前老的模块化规范，现在很少用了。\n\n## 讲一下你最常用的git命令，你们团队的git提交规范是什么？\n\n### 常用命令\n\n- git init: 初始化Git仓库。\n- git clone：克隆远程仓库到本地。\n- git add：保存修改。\n- git commit：提交修改。\n- git push：将本地仓库的修改推送到远程仓库。\n- git pull：从远程仓库拉取最新的修改到本地仓库。\n- git stash：暂存当前工作区，以便后续恢复。\n- git reset: 恢复到指定的提交。\n- git revert: 撤销指定的提交。\n- git branch: 列出当前所有分支。\n- git checkout: 切换到指定分支或提交。\n- git merge: 将指定分支合并到当前分支。\n\n### 提交规范\n\n一般采用 Angular 团队提出的 Commit Message Conventions。\n\n1. 每次提交都应该包含一个 Header，格式为 `\u003ctype\u003e(\u003cscope\u003e): \u003csubject\u003e`，其中 `\u003ctype\u003e` 表示提交的类型，包括以下几种：feat（新功能）、fix（修复 bug）、docs（文档修改）、style（代码样式修改）、refactor（重构代码）、test（增加测试代码）、chore（构建过程或辅助工具的修改）；`\u003cscope\u003e` 表示影响的范围；`\u003csubject\u003e` 表示简要说明。\n2. Header 应该在 50 个字符以内。\n3. Header 应该使用英文。\n4. Body 是可选的，用于更详细地说明修改内容，可以分成多行，每行不超过 72 个字符。\n5. Footer 也是可选的，用于关闭 Issue 或者列举重大变化等。 这种提交规范可以帮助团队更好地管理代码，方便追踪历史修改记录，提高代码质量。\n\n## 打包工具了解哪些，Webpack、Rollup、Parcel有什么区别？\nWebpack适合打包大型项目，可以处理多种文件类型，包括 JS、CSS、图片、字体等,另外通过Loader和Plugin机制提供了丰富的扩展功能。\n\nRollup适合JS库打包。Rollup的特点是生成的代码简洁，不会出现冗余的代码，因此适合用于构建库或插件等独立的组件。\n\nParcel使用简单，适用于小型项目和个人项目打包。\n\n## 有用过Vite吗，为什么Vite会那么快？\n\n1. 在开发环境下利用Chrome原生支持ESM的新特性，减少了处理import的消耗。\n\n2. 静态分析和模块预构建：Vite 在启动时，会分析项目中的所有模块，并提前编译和缓存这些模块，以便在需要时能够快速地提供给浏览器。这样可以避免了每次修改代码时重新构建的时间浪费。\n\n3. Vite内部使用ESBuild来处理TS，比TSC性能要好很多。\n\n## 你怎么理解前端基建？\n\n包括但不限于：\n\n- 规范建设，给团队指定编码和提交规范。\n- 文档建设，包括组件文档、业务文档、接口文档、跨端跨部门文档。\n- 安全建设。\n- 性能体系、埋点体系。\n- 组件库和类库建设。\n- BFF方案，包括SSR和GraphQL.\n- 微前端方案。\n- 脚手架。\n- 低代码。\n\n## 有了解过Rust吗？在前端有哪些应用？\nRust特点：简单概括就是高性能、语法多、学习难。(鉴于此，后续我会出一个教前端同学入门Rust的专栏。)\n\nRust的语法特性包括：所有权、借用、trait、泛型、模式匹配、宏等。\n\nRust在前端领域主要应用有WASM和前端基建，并且已经有了不少实战。比如：\n\n1. Yew：一个用Rust开发WASM应用的框架，开发体验类似于React，甚至也有Yew Hooks。\n2. Deno：JS和TS运行时，相当于更安全，性能更好的Nodejs。\n3. SWC：相当于Rust版的Babel。\n4. Turbopack、RSpack：相当于Rust版的Webpack。\n\n## 微前端适用于什么场景？设计一个微前端框架要怎么考虑？\n\n微前端适用于以下场景：\n\n1. 随着项目规模逐渐扩大，团队协作效率降低，可以考虑将大项目拆分成多个小项目，每个小项目都由独立的小型团队独立开发独立部署，\n2. 团队技术栈不同，可以将项目拆分，每个子项目采用不同技术栈开发，然后用微前端框架把项目组合在一块。\n\n设计一个微前端框架，需要考虑：\n\n1. 样式隔离：样式隔离可以采用的方案有CSS Modules、Shadow DOM、CSS-in-JS或者命名约定的方式。\n2. JS隔离：JS隔离需要创建沙箱环境，JS里可以通过Web Worker或者iframe来创建沙箱，还可以通过IIFE(立即调用表达式)来创建沙箱。\n3. 应用通信：应用之间可以采取URL参数传递信息、事件总线或者全局变量(会造成命名冲突和状态污染、，不够优雅)来实现通信。\n4. 路由管理：微前端中的路由管理，主要包括两个方面的内容：一是在宿主应用中对微前端应用的路由进行管理，二是在微前端应用内部实现自身的路由管理。\n5. 代码共享：可以通过将公用代码提取成三方库的形式来共享代码，还可以采用Webpack5的模块联邦来实现代码共享。\n","slug":"interview-engine","html":"\u003ch2\u003e什么是前端工程化？\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e模块化：AMD、CMD、commonjs、ESM。\u003c/li\u003e\n\u003cli\u003e自动化：自动化测试、自动化构建、自动化部署。\u003c/li\u003e\n\u003cli\u003e规范化：Vue编码规范、React编码规范、Git提交规范、文档规范。\u003c/li\u003e\n\u003cli\u003e各种工具：Webpack、Rollup、Vite、Babel、PostCSS。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e包管理器用的哪个？\u003c/h2\u003e\n\u003cp\u003enpm、cnpm、yarn、pnpm，或者有些大公司会自建包管理器。\u003c/p\u003e\n\u003cp\u003enpm和yarn的原理类似，但是yarn相对来说速度更快。\u003c/p\u003e\n\u003cp\u003epnpm与npm、yarn不同，pnpm不会将每个包都复制到项目的node_modules文件夹中，而是将所有包放在一个公共存储库中，并且在需要使用包时将其链接到项目中。这种方法可以减少磁盘使用量，并提高安装和更新速度。\u003c/p\u003e\n\u003cp\u003e推荐使用yarn和pnpm，速度更快，更稳定。\u003c/p\u003e\n\u003ch2\u003e有没有写过自动化测试，怎么做前端自动化测试？\u003c/h2\u003e\n\u003ch3\u003e测试的优缺点\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e优点：提高测试效率、确保代码质量，重构舒服\u003c/li\u003e\n\u003cli\u003e缺点：学习成本高，需要额外的时间来思考和编写测试代码\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e测试的分类\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e单元测试：针对代码的最小单元进行测试，例如测试函数或模块等。\u003c/li\u003e\n\u003cli\u003e集成测试：将多个模块组合在一起进行测试，确保它们在一起能够正确地工作。\u003c/li\u003e\n\u003cli\u003e端到端测试：模拟用户在应用程序中执行操作的场景，例如点击按钮、输入文本等。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e测试常用框架\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eJest\u003c/strong\u003e：基础测试框架，一般测试就是选个基础框架，然后再选一些测试工具。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003evue-test-utils\u003c/strong\u003e：vue-test-utils 是一个 Vue.js 官方的单元测试实用工具库，提供了许多 API 来方便地测试 Vue 组件。在单元测试中，可以通过模拟组件的 props、methods、data 等属性和方法，以及通过创建 wrapper 对象来访问组件实例的生命周期钩子函数，来进行组件的测试。此外，还可以使用 snapshot 测试来测试组件的渲染输出是否符合预期。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eCypress\u003c/strong\u003e：Cypress是一个用于 Web 应用程序的端到端测试工具，它可以模拟用户操作和行为，以及监控页面状态和 DOM 变化等。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eEnzyme\u003c/strong\u003e：Enzyme 是一个 React 组件测试实用工具库，提供了许多 API 来方便地测试 React 组件。在单元测试中，可以通过模拟组件的 props、state、函数和生命周期钩子等属性和方法，以及通过创建 wrapper 对象来访问组件实例的 DOM 节点和事件，来进行组件的测试。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e测试检验结果\u003c/h3\u003e\n\u003cp\u003e通过测试覆盖率当成测试的检验结果，测试覆盖率是衡量测试用例覆盖源代码的程度的指标，包括行覆盖率、分支覆盖率、函数覆盖率和语句覆盖率。测试覆盖率可以评估测试用例的质量和完整性，帮助开发人员确定需要更多测试的部分，并作为一种度量软件质量的指标。覆盖率越高，说明被测试的代码被验证的越充分，软件更加稳定和可靠。\u003c/p\u003e\n\u003ch3\u003e总结\u003c/h3\u003e\n\u003cp\u003e一般在项目里如果只是做UI开发，大多数情况下不用写自动化测试，但是一些封装的工具，组件库，插件之类的，可以写测试提高代码健壮性。\u003c/p\u003e\n\u003ch2\u003e什么是持续集成？\u003c/h2\u003e\n\u003cp\u003e持续集成，简称CI。CI有以下好处：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCI作为敏捷开发重要的一步，其目的在于让产品快速迭代的同时，尽可能保持高质量.\u003c/li\u003e\n\u003cli\u003eCI可以增加项目可见性，降低项目失败风险的开发实践。其每一次代码更新，都要通过自动化测试来检测代码和功能的正确性，只有通过自动测试的代码才能进行后续的交付和部署.\u003c/li\u003e\n\u003cli\u003eCI 是团队成员间（产研测）更好地协调工作，更好的适应敏捷迭代开发，自动完成减少人工干预，保证每个时间点上团队成员提交的代码都能成功集成的，可以很好的用于对各种WEB、APP项目的打包.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e一般是借助Jenkins、Docker、Travis、GitLab等工具来实现，大多数时候是由后端或者运维来做这个事的，但是在公司没有专业运维的情况下，前端负责人也可以考虑给项目上持续集成。\u003c/p\u003e\n\u003ch2\u003e用过Babel吗？讲一下你对Babel的了解？\u003c/h2\u003e\n\u003cp\u003eBabel是一个JS编译器，用通俗的话解释就是它主要用于将高版本的JavaScript代码转为向后兼容的JS代码，从而能让我们的代码运行在更低版本的浏览器或者其他的环境中。\u003c/p\u003e\n\u003cp\u003eBabel的核心就是plugin、preset。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eplugin\u003c/strong\u003e：Babel功能的实现就是靠着各种plugin，Babel插件包括语法插件和转换插件。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003epreset\u003c/strong\u003e：预设，一组plugin的组合，共同完成一个大功能。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eBabel执行原理:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e解析: 将代码字符串转换成 AST抽象语法树\u003c/li\u003e\n\u003cli\u003e转换: 访问AST的节点进行变换操作生成新的 AST\u003c/li\u003e\n\u003cli\u003e生成: 以新的AST为基础生成代码\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eESLint有什么用？你有用它来规范过团队代码吗？\u003c/h2\u003e\n\u003cp\u003eESLint是JS代码检查工具，可以用来规范前端代码风格和发现潜在的代码错误。\u003c/p\u003e\n\u003cp\u003e很多初学者不愿意用这样的代码检查工具，因为总会报错。但是对于有经验的开发者或者说团队管理者来说，它可以规范团队小伙伴的编码风格。\u003c/p\u003e\n\u003cp\u003eESLint常用的配置有：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003erules：指定规则，包括警告和错误规则，可以覆盖继承规则集中的规则或自定义规则。\u003c/li\u003e\n\u003cli\u003eplugins：指定插件，可以使用已有的插件如eslint-plugin-react或自定义插件。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e讲一下你了解哪些前端模块化规范？\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eES6 模块化：ES6 模块化是一种 JavaScript 模块化规范，是 ES6 中新增的语言特性。在 ES6 中，每个模块都是一个独立的文件，并通过 export 导出模块，通过 import 导入模块。例如：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// 导出模块\nexport var foo = 'bar';\nexport function add(x, y) {\n  return x + y;\n}\n\n// 导入模块\nimport {foo, add} from 'module';\nconsole.log(foo); // 'bar'\nconsole.log(add(1, 2)); // 3\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eCommonJS：Node.js的模块化规范。在CommonJS中，每个模块都是一个单独的文件，并通过module.exports导出模块，通过require()导入模块。例如：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// 导出模块\nmodule.exports = {\n  foo: 'bar',\n  add: function(x, y) {\n    return x + y;\n  }\n};\n\n// 导入模块\nvar module = require('module');\nconsole.log(module.foo); // 'bar'\nconsole.log(module.add(1, 2)); // 3\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eAMD和CMD：以前老的模块化规范，现在很少用了。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e讲一下你最常用的git命令，你们团队的git提交规范是什么？\u003c/h2\u003e\n\u003ch3\u003e常用命令\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003egit init: 初始化Git仓库。\u003c/li\u003e\n\u003cli\u003egit clone：克隆远程仓库到本地。\u003c/li\u003e\n\u003cli\u003egit add：保存修改。\u003c/li\u003e\n\u003cli\u003egit commit：提交修改。\u003c/li\u003e\n\u003cli\u003egit push：将本地仓库的修改推送到远程仓库。\u003c/li\u003e\n\u003cli\u003egit pull：从远程仓库拉取最新的修改到本地仓库。\u003c/li\u003e\n\u003cli\u003egit stash：暂存当前工作区，以便后续恢复。\u003c/li\u003e\n\u003cli\u003egit reset: 恢复到指定的提交。\u003c/li\u003e\n\u003cli\u003egit revert: 撤销指定的提交。\u003c/li\u003e\n\u003cli\u003egit branch: 列出当前所有分支。\u003c/li\u003e\n\u003cli\u003egit checkout: 切换到指定分支或提交。\u003c/li\u003e\n\u003cli\u003egit merge: 将指定分支合并到当前分支。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e提交规范\u003c/h3\u003e\n\u003cp\u003e一般采用 Angular 团队提出的 Commit Message Conventions。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e每次提交都应该包含一个 Header，格式为 \u003ccode\u003e\u0026#x3C;type\u003e(\u0026#x3C;scope\u003e): \u0026#x3C;subject\u003e\u003c/code\u003e，其中 \u003ccode\u003e\u0026#x3C;type\u003e\u003c/code\u003e 表示提交的类型，包括以下几种：feat（新功能）、fix（修复 bug）、docs（文档修改）、style（代码样式修改）、refactor（重构代码）、test（增加测试代码）、chore（构建过程或辅助工具的修改）；\u003ccode\u003e\u0026#x3C;scope\u003e\u003c/code\u003e 表示影响的范围；\u003ccode\u003e\u0026#x3C;subject\u003e\u003c/code\u003e 表示简要说明。\u003c/li\u003e\n\u003cli\u003eHeader 应该在 50 个字符以内。\u003c/li\u003e\n\u003cli\u003eHeader 应该使用英文。\u003c/li\u003e\n\u003cli\u003eBody 是可选的，用于更详细地说明修改内容，可以分成多行，每行不超过 72 个字符。\u003c/li\u003e\n\u003cli\u003eFooter 也是可选的，用于关闭 Issue 或者列举重大变化等。 这种提交规范可以帮助团队更好地管理代码，方便追踪历史修改记录，提高代码质量。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e打包工具了解哪些，Webpack、Rollup、Parcel有什么区别？\u003c/h2\u003e\n\u003cp\u003eWebpack适合打包大型项目，可以处理多种文件类型，包括 JS、CSS、图片、字体等,另外通过Loader和Plugin机制提供了丰富的扩展功能。\u003c/p\u003e\n\u003cp\u003eRollup适合JS库打包。Rollup的特点是生成的代码简洁，不会出现冗余的代码，因此适合用于构建库或插件等独立的组件。\u003c/p\u003e\n\u003cp\u003eParcel使用简单，适用于小型项目和个人项目打包。\u003c/p\u003e\n\u003ch2\u003e有用过Vite吗，为什么Vite会那么快？\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e在开发环境下利用Chrome原生支持ESM的新特性，减少了处理import的消耗。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e静态分析和模块预构建：Vite 在启动时，会分析项目中的所有模块，并提前编译和缓存这些模块，以便在需要时能够快速地提供给浏览器。这样可以避免了每次修改代码时重新构建的时间浪费。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eVite内部使用ESBuild来处理TS，比TSC性能要好很多。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e你怎么理解前端基建？\u003c/h2\u003e\n\u003cp\u003e包括但不限于：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e规范建设，给团队指定编码和提交规范。\u003c/li\u003e\n\u003cli\u003e文档建设，包括组件文档、业务文档、接口文档、跨端跨部门文档。\u003c/li\u003e\n\u003cli\u003e安全建设。\u003c/li\u003e\n\u003cli\u003e性能体系、埋点体系。\u003c/li\u003e\n\u003cli\u003e组件库和类库建设。\u003c/li\u003e\n\u003cli\u003eBFF方案，包括SSR和GraphQL.\u003c/li\u003e\n\u003cli\u003e微前端方案。\u003c/li\u003e\n\u003cli\u003e脚手架。\u003c/li\u003e\n\u003cli\u003e低代码。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e有了解过Rust吗？在前端有哪些应用？\u003c/h2\u003e\n\u003cp\u003eRust特点：简单概括就是高性能、语法多、学习难。(鉴于此，后续我会出一个教前端同学入门Rust的专栏。)\u003c/p\u003e\n\u003cp\u003eRust的语法特性包括：所有权、借用、trait、泛型、模式匹配、宏等。\u003c/p\u003e\n\u003cp\u003eRust在前端领域主要应用有WASM和前端基建，并且已经有了不少实战。比如：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eYew：一个用Rust开发WASM应用的框架，开发体验类似于React，甚至也有Yew Hooks。\u003c/li\u003e\n\u003cli\u003eDeno：JS和TS运行时，相当于更安全，性能更好的Nodejs。\u003c/li\u003e\n\u003cli\u003eSWC：相当于Rust版的Babel。\u003c/li\u003e\n\u003cli\u003eTurbopack、RSpack：相当于Rust版的Webpack。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e微前端适用于什么场景？设计一个微前端框架要怎么考虑？\u003c/h2\u003e\n\u003cp\u003e微前端适用于以下场景：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e随着项目规模逐渐扩大，团队协作效率降低，可以考虑将大项目拆分成多个小项目，每个小项目都由独立的小型团队独立开发独立部署，\u003c/li\u003e\n\u003cli\u003e团队技术栈不同，可以将项目拆分，每个子项目采用不同技术栈开发，然后用微前端框架把项目组合在一块。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e设计一个微前端框架，需要考虑：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e样式隔离：样式隔离可以采用的方案有CSS Modules、Shadow DOM、CSS-in-JS或者命名约定的方式。\u003c/li\u003e\n\u003cli\u003eJS隔离：JS隔离需要创建沙箱环境，JS里可以通过Web Worker或者iframe来创建沙箱，还可以通过IIFE(立即调用表达式)来创建沙箱。\u003c/li\u003e\n\u003cli\u003e应用通信：应用之间可以采取URL参数传递信息、事件总线或者全局变量(会造成命名冲突和状态污染、，不够优雅)来实现通信。\u003c/li\u003e\n\u003cli\u003e路由管理：微前端中的路由管理，主要包括两个方面的内容：一是在宿主应用中对微前端应用的路由进行管理，二是在微前端应用内部实现自身的路由管理。\u003c/li\u003e\n\u003cli\u003e代码共享：可以通过将公用代码提取成三方库的形式来共享代码，还可以采用Webpack5的模块联邦来实现代码共享。\u003c/li\u003e\n\u003c/ol\u003e\n"}},"__N_SSG":true},"page":"/[slug]","query":{"slug":"interview-engine"},"buildId":"u_x12eLn2XCxdSz5n9-ra","assetPrefix":"/interview","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>